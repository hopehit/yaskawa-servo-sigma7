/****************************************************************************************************/
/*																									*/
/*																									*/
/*		TstIxInst.c : Test IxInst Functions															*/
/*																									*/
/*																									*/
/****************************************************************************************************/
/*																									*/
/*																									*/
/*		1) TstIxInstBasic16() : Test Basic Instructions (16bit)										*/
/*		2) TstIxInstBasic32() : Test Basic Instructions (36bit)										*/
/*		3) TstIxInstShift16() : Test Shift Instructions (16bit)										*/
/*		4) TstIxInstShift32() : Test Shift Instructions (32bit)										*/
/*		5) TstIxInstLimit16() : Test Limit Instructions (16bit)										*/
/*		6) TstIxInstLimit32() : Test Limit Instructions (32bit)										*/
/*		7) TstIxInstTable16() : Test Read RomTable Instructions										*/
/*		8) TstIxInstOther16() : Test Other Instructions (16bit)										*/
/*		9) TstIxInstOther32() : Test Other Instructions (32bit)										*/
/*	   10) TstIxInstMulgainXX() : Test MulgainXX Instructions										*/
/*	   11) TstIxInstIntegral()  : Test Integral  Instruction										*/
/*	   12) TstIxInstMulhigh32() : Test Mulhigh32 Instruction										*/
/*	   13) TstIxInstLpfilter1() : Test Lpfilter1/Hpfilter1 Instruction								*/
/*	   14) TstIxInstNxfilter2() : Test Nxfilter2 Instruction										*/
/*																									*/
/*																									*/
/************** Copyright Yaskawa Electric Corporation **********************************************/
/*																									*/
/*		Rev.1.00 : 2007.02.24	T.Taniguchi															*/
/*		Rev.1.10 : 2008.01.08	T.Taniguchi		Add TstIxInstIntegral()								*/
/*		Rev.1.11 : 2008.06.25	T.Taniguchi		Add TstIxInstNxfilter2()							*/
/*																									*/
/****************************************************************************************************/



/****************************************************************************************************/
/*		Const Data Definition																		*/
/****************************************************************************************************/
#define LPX_REG16_MAX	 32767
#define LPX_REG16_MIN	-32768
/*--------------------------------------------------------------------------------------------------*/
#define LPX_REG32_MAX	(LONG)0x7FFFFFFF
#define LPX_REG32_MIN	(LONG)0x80000000
/****************************************************************************************************/
/*		Data Type Definition																		*/
/****************************************************************************************************/
typedef SHORT	REG16;
typedef USHORT	UREG16;
typedef LONG	REG32;
typedef ULONG	UREG32;
/*--------------------------------------------------------------------------------------------------*/





/****************************************************************************************************/
/*																									*/
/*		Macro Definition																			*/
/*																									*/
/****************************************************************************************************/
#define INT64_OF( xh, xl )	((((INT64)xh) << 32) + (ULONG)xl )
#define LPX_LIMIT( x, lmt )	(((x) > (lmt))? (lmt) : (((x) < -(lmt))? -(lmt) : (x)))
/*--------------------------------------------------------------------------------------------------*/
/*		Macro Definition for Display and Output to Log File											*/
/*--------------------------------------------------------------------------------------------------*/
#define	XprintF0( fp, fmt )			{ printf( fmt );       if(fp!=NULL){ fprintf( fp, fmt );}      }
#define	XprintF1( fp, fmt, x )		{ printf( fmt, x );    if(fp!=NULL){ fprintf( fp, fmt, x );}   }
#define	XprintF2( fp, fmt, x, y )	{ printf( fmt, x, y ); if(fp!=NULL){ fprintf( fp, fmt, x, y );}}
#define	XprintF3( fp, fmt,x,y,z )	{ printf( fmt,x,y,z ); if(fp!=NULL){ fprintf( fp, fmt,x,y,z );}}
/****************************************************************************************************/
/*																									*/
/*		Test Functions																				*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstMain( void );
LONG	TstIxInstBasic16( void );
LONG	TstIxInstBasic32( void );
LONG	TstIxInstShift16( void );
LONG	TstIxInstShift32( void );
LONG	TstIxInstLimit16( void );
LONG	TstIxInstLimit32( void );
LONG	TstIxInstTable16( void );
LONG	TstIxInstOther16( void );
LONG	TstIxInstOther32( void );
/*--------------------------------------------------------------------------------------------------*/
LONG	TstIxInstMulgainXX( void );
LONG	TstIxInstIntegral( void );
LONG	TstIxInstMulhigh32( void );
LONG	TstIxInstLpfilter1( void );
LONG	TstIxInstNxfilter2( void );
/*--------------------------------------------------------------------------------------------------*/
/*		Check Flag Function																			*/
/*--------------------------------------------------------------------------------------------------*/
LONG	LpxChkFlag16( LONG x, LONG ChkFlag );
LONG	LpxChkFlag32( INT64 x, LONG ChkFlag );
/*--------------------------------------------------------------------------------------------------*/
#define CHKFLAG_Z			0x01
#define CHKFLAG_ZSCB		0x02
#define CHKFLAG_SAR_CB		0x03
/*--------------------------------------------------------------------------------------------------*/



/****************************************************************************************************/
/*																									*/
/*		Test Data																					*/
/*																									*/
/****************************************************************************************************/
typedef struct	{
		SHORT	In16A;
		SHORT	In16B;
		LONG	In32A;
		LONG	In32B;
} TDATA;
const	TDATA	TstData[] = {
/*--------------------------------------------------------------------------------------------------*/
/*		In16A		In16B		In32A		In32B													*/
/*--------------------------------------------------------------------------------------------------*/
		0x0000,		0x0000,		0x00000000,	0x00000000,
		0x0001,		0x0000,		0x00000001, 0x00000000,
		0x0000,		0x0001,		0x00000000, 0x00000001,
		0x0001,		0x0001,		0x00000001, 0x00000001,
/*--------------------------------------------------------------------------------------------------*/
		0x1111,		0x2222,		0x11111111, 0x22222222,
		0x2222,		0x1111,		0x22222222, 0x11111111,
		0x1234,		0x4567,		0x12341234, 0x45674567,
		0x4567,		0x1234,		0x45674567, 0x12341234,
/*--------------------------------------------------------------------------------------------------*/
		0x3FFF,		0x3FFF,		0x3FFFFFFF, 0x3FFFFFFF,
		0x3FFF,		0x4000,		0x3FFFFFFF, 0x40000000,
		0x4000,		0x3FFF,		0x40000000, 0x3FFFFFFF,
		0x4000,		0x4000,		0x40000000, 0x40000000,
/*--------------------------------------------------------------------------------------------------*/
		0x4444,		0x5555,		0x44444444, 0x55555555,
		0x5555,		0x4444,		0x55555555, 0x44444444,
		0x6666,		0x7777,		0x66666666, 0x77777777,
		0x7777,		0x6666,		0x77777777, 0x66666666,
/*--------------------------------------------------------------------------------------------------*/
		0x7FFF,		0x7FFF,		0x7FFFFFFF, 0x7FFFFFFF,
		0x7FFF,		0x8000,		0x7FFFFFFF, 0x80000000,
		0x8000,		0x7FFF,		0x80000000, 0x7FFFFFFF,
		0x8000,		0x8000,		0x80000000, 0x80000000,
/*--------------------------------------------------------------------------------------------------*/
		0x9999,		0x9999,		0x99999999, 0x99999999,
		0x9999,		0xAAAA,		0x99999999, 0xAAAAAAAA,
		0xAAAA,		0x9999,		0xAAAAAAAA, 0x99999999,
		0xAAAA,		0xAAAA,		0xAAAAAAAA, 0xAAAAAAAA,
/*--------------------------------------------------------------------------------------------------*/
		0xBBBB,		0xBBBB,		0xBBBBBBBB, 0xBBBBBBBB,
		0xBBBB,		0xCCCC,		0xBBBBBBBB, 0xCCCCCCCC,
		0xCCCC,		0xBBBB,		0xCCCCCCCC, 0xBBBBBBBB,
		0xCCCC,		0xCCCC,		0xCCCCCCCC, 0xCCCCCCCC,
/*--------------------------------------------------------------------------------------------------*/
		0xDDDD,		0xDDDD,		0xDDDDDDDD, 0xDDDDDDDD,
		0xDDDD,		0xEEEE,		0xDDDDDDDD, 0xEEEEEEEE,
		0xEEEE,		0xDDDD,		0xEEEEEEEE, 0xDDDDDDDD,
		0xEEEE,		0xEEEE,		0xEEEEEEEE, 0xEEEEEEEE,
/*--------------------------------------------------------------------------------------------------*/
		0xFFFE,		0xFFFE,		0xFFFFFFFE, 0xFFFFFFFE,
		0xFFFE,		0xFFFF,		0xFFFFFFFE, 0xFFFFFFFF,
		0xFFFF,		0xFFFE,		0xFFFFFFFF, 0xFFFFFFFE,
		0xFFFF,		0xFFFF,		0xFFFFFFFF, 0xFFFFFFFF,
};
/*--------------------------------------------------------------------------------------------------*/





/****************************************************************************************************/
/*																									*/
/*		Test IxInst Main																			*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstMain( void )
{

/*--------------------------------------------------------------------------------------------------*/
/*		Call Test Function																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( TstIxInstBasic16( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstBasic32( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstShift16( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstShift32( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstLimit16( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstLimit32( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstTable16( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstOther16( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstOther32( ) != TSTOK ){ return( TSTNG );}
/*--------------------------------------------------------------------------------------------------*/
		if( TstIxInstMulgainXX( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstMulhigh32( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstIntegral( )  != TSTOK ){ return( TSTNG );}
		if( TstIxInstLpfilter1( ) != TSTOK ){ return( TSTNG );}
		if( TstIxInstNxfilter2( ) != TSTOK ){ return( TSTNG );}
/*--------------------------------------------------------------------------------------------------*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Check Flag for 16bit Cal.																	*/
/*																									*/
/****************************************************************************************************/
LONG	LpxChkFlag16( LONG x, LONG ChkFlag )
{
SHORT	y = (SHORT)x;
LONG	TstNgCnt = 0;

/*--------------------------------------------------------------------------------------------------*/
/*		Check Flag Z																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( ChkFlag == CHKFLAG_Z )
		{
			if( (y == 0 ) && (Flag.Zero == 0) ){ TstNgCnt++;}
			if( (y != 0 ) && (Flag.Zero != 0) ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check Flag Z,S,C,B																			*/
/*--------------------------------------------------------------------------------------------------*/
		else if( ChkFlag == CHKFLAG_ZSCB )
		{
			if( (y == 0 ) && (Flag.Zero == 0) ){ TstNgCnt++;}
			if( (y != 0 ) && (Flag.Zero != 0) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			if( (y <  0 ) && (Flag.Sign == 0) ){ TstNgCnt++;}
			if( (y >= 0 ) && (Flag.Sign != 0) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			if( (x >  LPX_REG16_MAX) && (Flag.Carry  == 0) ){ TstNgCnt++;}
			if( (x <= LPX_REG16_MAX) && (Flag.Carry  != 0) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			if( (x <  LPX_REG16_MIN) && (Flag.Borrow == 0) ){ TstNgCnt++;}
			if( (x >= LPX_REG16_MIN) && (Flag.Borrow != 0) ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check Flag C,B for IxSAR32																	*/
/*--------------------------------------------------------------------------------------------------*/
		else if( ChkFlag == CHKFLAG_SAR_CB )
		{
			if( (x >  LPX_REG16_MAX) && (Flag.Carry  == 0) ){ TstNgCnt++;}
			if( (x <= LPX_REG16_MAX) && (Flag.Carry  != 0) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			if( (x <  LPX_REG16_MIN) && (Flag.Borrow == 0) ){ TstNgCnt++;}
			if( (x >= LPX_REG16_MIN) && (Flag.Borrow != 0) ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check Type NG																				*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			TstNgCnt++;
		}
/*--------------------------------------------------------------------------------------------------*/
		return( TstNgCnt );
}



/****************************************************************************************************/
/*																									*/
/*		Check Flag for 32bit Cal.																	*/
/*																									*/
/****************************************************************************************************/
LONG	LpxChkFlag32( INT64 x, LONG ChkFlag )
{
LONG	y = (LONG)x;
LONG	TstNgCnt = 0;

/*--------------------------------------------------------------------------------------------------*/
/*		Check Flag Z																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( ChkFlag == CHKFLAG_Z )
		{
			if( (y == 0 ) && (Flag.Zero == 0) ){ TstNgCnt++;}
			if( (y != 0 ) && (Flag.Zero != 0) ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check Flag Z,S,C,B																			*/
/*--------------------------------------------------------------------------------------------------*/
		else if( ChkFlag == CHKFLAG_ZSCB )
		{
			if( (y == 0 ) && (Flag.Zero == 0) ){ TstNgCnt++;}
			if( (y != 0 ) && (Flag.Zero != 0) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			if( (y <  0 ) && (Flag.Sign == 0) ){ TstNgCnt++;}
			if( (y >= 0 ) && (Flag.Sign != 0) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			if( (x >  LPX_REG32_MAX) && (Flag.Carry  == 0) ){ TstNgCnt++;}
			if( (x <= LPX_REG32_MAX) && (Flag.Carry  != 0) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			if( (x <  LPX_REG32_MIN) && (Flag.Borrow == 0) ){ TstNgCnt++;}
			if( (x >= LPX_REG32_MIN) && (Flag.Borrow != 0) ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check Flag C,B for IxSAR32																	*/
/*--------------------------------------------------------------------------------------------------*/
		else if( ChkFlag == CHKFLAG_SAR_CB )
		{
			if( (x >  LPX_REG32_MAX) && (Flag.Carry  == 0) ){ TstNgCnt++;}
			if( (x <= LPX_REG32_MAX) && (Flag.Carry  != 0) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			if( (x <  LPX_REG32_MIN) && (Flag.Borrow == 0) ){ TstNgCnt++;}
			if( (x >= LPX_REG32_MIN) && (Flag.Borrow != 0) ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check Type NG																				*/
/*--------------------------------------------------------------------------------------------------*/
		else
		{
			TstNgCnt++;
		}
/*--------------------------------------------------------------------------------------------------*/
		return( TstNgCnt );
}



/****************************************************************************************************/
/*																									*/
/*		Test Basic Instructions : IxMovXxx16, IxAddXxx16, IxAndXxx16, etc							*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstBasic16( void )
{
LONG	i;
LONG	x;
SHORT	In16[2];
SHORT	Reg16[2];
LONG	In32[2];
LONG	Reg32[2];
LONG	TstNgCnt = 0;
LONG	TstDatNum = sizeof(TstData) / sizeof(TstData[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Test IxMovImm16/IxMovReg16																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
			IxMovImm16( &Reg16[0], In16[0] );
			if( Reg16[0] != In16[0] ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			IxMovReg16( &Reg16[0], In16[0] );
			if( Reg16[0] != In16[0] ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxAddXxx16/IxSubXxx16																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxAddImm16/IxAddReg16															*/
		/*------------------------------------------------------------------------------------------*/
			Reg16[0] = In16[0];
			x = Reg16[0] + In16[1];
			IxAddImm16( &Reg16[0], In16[1] );
			if( Reg16[0] != (REG16)x ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_ZSCB );
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] + In16[1];
			IxAddReg16( &Reg16[0], In16[0], In16[1] );
			if( Reg16[0] != (REG16)x ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_ZSCB );
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSubImm16/IxSubReg16															*/
		/*------------------------------------------------------------------------------------------*/
			Reg16[0] = In16[0];
			x = Reg16[0] - In16[1];
			IxSubImm16( &Reg16[0], In16[1] );
			if( Reg16[0] != (REG16)x ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_ZSCB );
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] - In16[1];
			IxSubReg16( &Reg16[0], In16[0], In16[1] );
			if( Reg16[0] != (REG16)x ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_ZSCB );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxCmpImm16/IxCmpReg16																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] - In16[1];
			IxCmpImm16( In16[0], In16[1] );
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_ZSCB );
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] - In16[1];
			IxCmpReg16( In16[0], In16[1] );
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_ZSCB );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxAndXxx16/IxOrXxx16/IxXorXxx16														*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxAndImm16/IxAndReg16															*/
		/*------------------------------------------------------------------------------------------*/
			x = (UREG16)(In16[0] & In16[1]);
			IxMovReg16( &Reg16[0], In16[0] );
			IxAndImm16( &Reg16[0], In16[1] );
			if( x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
			x = (UREG16)(In16[0] & In16[1]);
			IxAndReg16( &Reg16[0], In16[0], In16[1] );
			if( x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxOrImm16/IxOrReg16															*/
		/*------------------------------------------------------------------------------------------*/
			x = (UREG16)(In16[0] | In16[1]);
			IxMovReg16( &Reg16[0], In16[0] );
			IxOrImm16( &Reg16[0], In16[1] );
			if( x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
			x = (UREG16)(In16[0] | In16[1]);
			IxOrReg16( &Reg16[0], In16[0], In16[1] );
			if( x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxXorImm16/IxXorReg16															*/
		/*------------------------------------------------------------------------------------------*/
			x = (UREG16)(In16[0] ^ In16[1]);
			IxMovReg16( &Reg16[0], In16[0] );
			IxXorImm16( &Reg16[0], In16[1] );
			if( x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
			x = (UREG16)(In16[0] ^ In16[1]);
			IxXorReg16( &Reg16[0], In16[0], In16[1] );
			if( x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag16( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxInvReg16																		*/
		/*------------------------------------------------------------------------------------------*/
			x = (UREG16)(~In16[0]);
			IxInvReg16( &Reg16[0], In16[0] );
			if( x != (UREG16)Reg16[0] ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxExtS16/IxExtU16																		*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxExtS16																		*/
		/*------------------------------------------------------------------------------------------*/
			x = (LONG)((SHORT)In16[0]);
			IxExtS16( &Reg32[0], In16[0] );
			if( x != Reg32[0] ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxExtU16																		*/
		/*------------------------------------------------------------------------------------------*/
			x = (LONG)((USHORT)In16[0]);
			IxExtU16( &Reg32[0], In16[0] );
			if( x != Reg32[0] ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxMulImm16/IxMulReg16																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] * In16[1];
			IxMulImm16( In16[0], In16[1] );
			if( x != MacL.l ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] * In16[1];
			IxMulReg16( In16[0], In16[1] );
			if( x != MacL.l ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxDivImm16/IxDivReg16/etc																*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
			In32[0] = TstData[i].In32A;
		/*------------------------------------------------------------------------------------------*/
			IxDivSet32( In16[0], In16[1] );
			if( IxReg.DivSet32 != ((((LONG)In16[0]) << 16) + (USHORT)In16[1]) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			IxDivImm16( &Reg16[0], In16[0] );
			if( In16[0] == 0 )
			{
				if( Flag.DivZero != 1 ){ TstNgCnt++;}
				if( Flag.DivOver != 1 ){ TstNgCnt++;}
			}
			else
			{
				x = IxReg.DivSet32 / In16[0];
				if( (SHORT)x != Reg16[0] ){ TstNgCnt++;}
				if( DivRem != (IxReg.DivSet32 - (x * In16[0])) ){ TstNgCnt++;}
			    if( (x > LPX_REG16_MAX) || (x < LPX_REG16_MIN) )
				{
					if( Flag.DivOver != 1 ){ TstNgCnt++;}
				}
				else
				{
					if( Flag.DivOver != 0 ){ TstNgCnt++;}
				}
			}
		/*------------------------------------------------------------------------------------------*/
			IxDivReg16( &Reg16[0], In16[0] );
			if( In16[0] == 0 )
			{
				if( Flag.DivZero != 1 ){ TstNgCnt++;}
				if( Flag.DivOver != 1 ){ TstNgCnt++;}
			}
			else
			{
				x = IxReg.DivSet32 / In16[0];
				if( (SHORT)x != Reg16[0] ){ TstNgCnt++;}
				if( DivRem != (IxReg.DivSet32 - (x * In16[0])) ){ TstNgCnt++;}
			    if( (x > LPX_REG16_MAX) || (x < LPX_REG16_MIN) )
				{
					if( Flag.DivOver != 1 ){ TstNgCnt++;}
				}
				else
				{
					if( Flag.DivOver != 0 ){ TstNgCnt++;}
				}
			}
		/*------------------------------------------------------------------------------------------*/
			IxDivR32R16( &Reg16[0], In32[0], In16[0] );
			if( In16[0] == 0 )
			{
				if( Flag.DivZero != 1 ){ TstNgCnt++;}
				if( Flag.DivOver != 1 ){ TstNgCnt++;}
			}
			else
			{
				x = In32[0] / In16[0];
				if( (SHORT)x != Reg16[0] ){ TstNgCnt++;}
				if( DivRem != (In32[0] - (x * In16[0])) ){ TstNgCnt++;}
			    if( (x > LPX_REG16_MAX) || (x < LPX_REG16_MIN) )
				{
					if( Flag.DivOver != 1 ){ TstNgCnt++;}
				}
				else
				{
					if( Flag.DivOver != 0 ){ TstNgCnt++;}
				}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt != 0 )
		{
			printf( "\nTstIxInstBasic16() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
		printf( "\nTstIxInstBasic16() : Complete" );
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Basic Instructions : IxMovXxx32, IxAddXxx32, IxAndXxx32, etc							*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstBasic32( void )
{
LONG	i;
INT64	x;
LONG	In32[2];
LONG	Reg32[2];
LONG	TstNgCnt = 0;
LONG	TstDatNum = sizeof(TstData) / sizeof(TstData[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Test IxMovImm32/IxMovReg32																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In32[0] = TstData[i].In32A;
			In32[1] = TstData[i].In32B;
		/*------------------------------------------------------------------------------------------*/
			IxMovImm32( &Reg32[0], In32[0] );
			if( Reg32[0] != In32[0] ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			IxMovReg32( &Reg32[0], In32[0] );
			if( Reg32[0] != In32[0] ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxAddXxx32/IxSubXxx32																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In32[0] = TstData[i].In32A;
			In32[1] = TstData[i].In32B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxAddImm32/IxAddReg32															*/
		/*------------------------------------------------------------------------------------------*/
			Reg32[0] = In32[0];
			x = (INT64)Reg32[0] + (INT64)In32[1];
			IxAddImm32( &Reg32[0], In32[1] );
			if( Reg32[0] != (REG32)x ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_ZSCB );
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] + (INT64)In32[1];
			IxAddReg32( &Reg32[0], In32[0], In32[1] );
			if( Reg32[0] != (REG32)x ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_ZSCB );
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSubImm32/IxSubReg32															*/
		/*------------------------------------------------------------------------------------------*/
			Reg32[0] = In32[0];
			x = (INT64)Reg32[0] - (INT64)In32[1];
			IxSubImm32( &Reg32[0], In32[1] );
			if( Reg32[0] != (REG32)x ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_ZSCB );
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] - (INT64)In32[1];
			IxSubReg32( &Reg32[0], In32[0], In32[1] );
			if( Reg32[0] != (REG32)x ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_ZSCB );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxCmpImm32/IxCmpReg32																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In32[0] = TstData[i].In32A;
			In32[1] = TstData[i].In32B;
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] - (INT64)In32[1];
			IxCmpImm32( In32[0], In32[1] );
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_ZSCB );
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] - (INT64)In32[1];
			IxCmpReg32( In32[0], In32[1] );
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_ZSCB );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxAndXxx32/IxOrXxx32/IxXorXxx32														*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In32[0] = TstData[i].In32A;
			In32[1] = TstData[i].In32B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxAndImm32/IxAndReg32															*/
		/*------------------------------------------------------------------------------------------*/
			x = (UREG32)(In32[0] & In32[1]);
			IxMovReg32( &Reg32[0], In32[0] );
			IxAndImm32( &Reg32[0], In32[1] );
			if( x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
			x = (UREG32)(In32[0] & In32[1]);
			IxAndReg32( &Reg32[0], In32[0], In32[1] );
			if( x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxOrImm32/IxOrReg32															*/
		/*------------------------------------------------------------------------------------------*/
			x = (UREG32)(In32[0] | In32[1]);
			IxMovReg32( &Reg32[0], In32[0] );
			IxOrImm32( &Reg32[0], In32[1] );
			if( x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
			x = (UREG32)(In32[0] | In32[1]);
			IxOrReg32( &Reg32[0], In32[0], In32[1] );
			if( x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxXorImm32/IxXorReg32															*/
		/*------------------------------------------------------------------------------------------*/
			x = (UREG32)(In32[0] ^ In32[1]);
			IxMovReg32( &Reg32[0], In32[0] );
			IxXorImm32( &Reg32[0], In32[1] );
			if( x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
			x = (UREG32)(In32[0] ^ In32[1]);
			IxXorReg32( &Reg32[0], In32[0], In32[1] );
			if( x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			TstNgCnt = TstNgCnt + LpxChkFlag32( x, CHKFLAG_Z );
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxInvReg32																		*/
		/*------------------------------------------------------------------------------------------*/
			x = (UREG32)(~In32[0]);
			IxInvReg32( &Reg32[0], In32[0] );
			if( x != (UREG32)Reg32[0] ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxMulImm32/IxMulReg32																	*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In32[0] = TstData[i].In32A;
			In32[1] = TstData[i].In32B;
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] * (INT64)In32[1];
			IxMulImm32( In32[0], In32[1] );
			if( x != INT64_OF( MacH.l, MacL.l ) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] * (INT64)In32[1];
			IxMulReg32( In32[0], In32[1] );
			if( x != INT64_OF( MacH.l, MacL.l ) ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt != 0 )
		{
			printf( "\nTstIxInstBasic32() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
		printf( "\nTstIxInstBasic32() : Complete" );
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Shift Instructions : IxSAR32, IxSAL32, IxSHR16, IxSHL16, etc							*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstShift16( void )
{
LONG	i,j;
LONG	x,y,z;
SHORT	In16[2];
SHORT	Reg16[2];
LONG	TstNgCnt = 0;
LONG	TstDatNum = sizeof(TstData) / sizeof(TstData[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Test IxSAR32																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSAR32Imm																		*/
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] * In16[1];
			IxMulImm16( In16[0], In16[1] );
			if( x != MacL.l ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 32; j++ )
			{
				IxSAR32Imm( &Reg16[0], (SHORT)j );
				if( j == 0 ){ y = x;}
				else		{ z = x >> (j-1); y = (z >> 1) + (z & 0x01);}
			/*--------------------------------------------------------------------------------------*/
				if( (SHORT)y != Reg16[0] ){ TstNgCnt++;}
				TstNgCnt = TstNgCnt + LpxChkFlag16( y, CHKFLAG_SAR_CB );
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSAR32Reg																		*/
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] * In16[1];
			IxMulImm16( In16[0], In16[1] );
			if( x != MacL.l ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 32; j++ )
			{
				IxSAR32Reg( &Reg16[0], (SHORT)j );
				if( j == 0 ){ y = x;}
				else		{ z = x >> (j-1); y = (z >> 1) + (z & 0x01);}
			/*--------------------------------------------------------------------------------------*/
				if( (SHORT)y != Reg16[0] ){ TstNgCnt++;}
				TstNgCnt = TstNgCnt + LpxChkFlag16( y, CHKFLAG_SAR_CB );
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxSAL32																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSAL32Imm																		*/
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] * In16[1];
			IxMulImm16( In16[0], In16[1] );
			if( x != MacL.l ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 32; j++ )
			{
				IxSAL32Imm( &Reg16[0], (SHORT)j );
				y = (x << j) >> 16;
			/*--------------------------------------------------------------------------------------*/
				if( (SHORT)y != Reg16[0] ){ TstNgCnt++;}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSAL32Reg																		*/
		/*------------------------------------------------------------------------------------------*/
			x = In16[0] * In16[1];
			IxMulImm16( In16[0], In16[1] );
			if( x != MacL.l ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 32; j++ )
			{
				IxSAL32Reg( &Reg16[0], (SHORT)j );
				y = (x << j) >> 16;
			/*--------------------------------------------------------------------------------------*/
				if( (SHORT)y != Reg16[0] ){ TstNgCnt++;}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxSHR16/IxSHL16																		*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSHR16/IxSHL16																*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 16; j++ )
			{
				IxSHR16Imm( &Reg16[0], In16[0], (SHORT)j );
				x = ((UREG16)In16[0]) >> j;
				if( (UREG16)x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxSHR16Reg( &Reg16[0], In16[0], (SHORT)j );
				x = ((UREG16)In16[0]) >> j;
				if( (UREG16)x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxSHL16Imm( &Reg16[0], In16[0], (SHORT)j );
				x = ((UREG16)In16[0]) << j;
				if( (UREG16)x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxSHL16Reg( &Reg16[0], In16[0], (SHORT)j );
				x = ((UREG16)In16[0]) << j;
				if( (UREG16)x != (UREG16)Reg16[0] ){ TstNgCnt++;}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt != 0 )
		{
			printf( "\nTstIxInstShift16() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
			printf( "\nTstIxInstShift16() : Complete" );
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Shift Instructions : IxSAR64, IxSAL64, IxSHR32, IxSHL32, etc							*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstShift32( void )
{
LONG	i,j;
INT64	x,y,z;
LONG	In32[2];
LONG	Reg32[2];
LONG	TstNgCnt = 0;
LONG	TstDatNum = sizeof(TstData) / sizeof(TstData[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Test IxSAR64																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In32[0] = TstData[i].In32A;
			In32[1] = TstData[i].In32B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSAR64Imm																		*/
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] * (INT64)In32[1];
			IxMulImm32( In32[0], In32[1] );
			if( x != INT64_OF( MacH.l, MacL.l ) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 64; j++ )
			{
				IxSAR64Imm( &Reg32[0], (SHORT)j );
				if( j == 0 ){ y = x;}
				else		{ z = x >> (j-1); y = (z >> 1) + (z & 0x01);}
			/*--------------------------------------------------------------------------------------*/
				if( (LONG)y != Reg32[0] ){ TstNgCnt++;}
				TstNgCnt = TstNgCnt + LpxChkFlag32( y, CHKFLAG_SAR_CB );
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSAR64Reg																		*/
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] * (INT64)In32[1];
			IxMulImm32( In32[0], In32[1] );
			if( x != INT64_OF( MacH.l, MacL.l ) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 64; j++ )
			{
				IxSAR64Reg( &Reg32[0], (SHORT)j );
				if( j == 0 ){ y = x;}
				else		{ z = x >> (j-1); y = (z >> 1) + (z & 0x01);}
			/*--------------------------------------------------------------------------------------*/
				if( (LONG)y != Reg32[0] ){ TstNgCnt++;}
				TstNgCnt = TstNgCnt + LpxChkFlag32( y, CHKFLAG_SAR_CB );
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxSAL64																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In32[0] = TstData[i].In32A;
			In32[1] = TstData[i].In32B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSAL64Imm																		*/
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] * (INT64)In32[1];
			IxMulImm32( In32[0], In32[1] );
			if( x != INT64_OF( MacH.l, MacL.l ) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 64; j++ )
			{
				IxSAL64Imm( &Reg32[0], (SHORT)j );
				y = (x << j) >> 32;
			/*--------------------------------------------------------------------------------------*/
				if( (LONG)y != Reg32[0] ){ TstNgCnt++;}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSAL64Reg																		*/
		/*------------------------------------------------------------------------------------------*/
			x = (INT64)In32[0] * (INT64)In32[1];
			IxMulImm32( In32[0], In32[1] );
			if( x != INT64_OF( MacH.l, MacL.l ) ){ TstNgCnt++;}
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 64; j++ )
			{
				IxSAL64Reg( &Reg32[0], (SHORT)j );
				y = (x << j) >> 32;
			/*--------------------------------------------------------------------------------------*/
				if( (LONG)y != Reg32[0] ){ TstNgCnt++;}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxSHR32/IxSHL32																		*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In32[0] = TstData[i].In32A;
			In32[1] = TstData[i].In32B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxSHR32/IxSHL32																*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 32; j++ )
			{
				IxSHR32Imm( &Reg32[0], In32[0], (SHORT)j );
				x = ((UREG32)In32[0]) >> j;
				if( (UREG32)x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxSHR32Reg( &Reg32[0], In32[0], (SHORT)j );
				x = ((UREG32)In32[0]) >> j;
				if( (UREG32)x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxSHL32Imm( &Reg32[0], In32[0], (SHORT)j );
				x = ((UREG32)In32[0]) << j;
				if( (UREG32)x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxSHL32Reg( &Reg32[0], In32[0], (SHORT)j );
				x = ((UREG32)In32[0]) << j;
				if( (UREG32)x != (UREG32)Reg32[0] ){ TstNgCnt++;}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt != 0 )
		{
			printf( "\nTstIxInstShift32() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
		printf( "\nTstIxInstShift32() : Complete" );
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Limit Instructions : IxLmtXxx16, IxLmtCBR16, IxLmtzXxx16, etc							*/
/*																									*/
/****************************************************************************************************/
#define LPX_CHK_LMTCBR16( x )	(FlagX.Carry || FlagX.Borrow || (x == -32768))
const	SHORT	TstLmt16[] = { 0, 100, 1000, 32767, -100, -1000, -32767, -32768 };
/*--------------------------------------------------------------------------------------------------*/
LONG	TstIxInstLimit16( void )
{
LONG	i,j;
LONG	x,y,z;
FLAG	FlagX;
SHORT	LmtIn;
SHORT	In16[2];
SHORT	Reg16[2];
LONG	TstNgCnt = 0;
LONG	TstDatNum = sizeof(TstData) / sizeof(TstData[0]);
LONG	TstLmtNum = sizeof(TstLmt16) / sizeof(TstLmt16[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Test IxLmtXxx16																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In16[0] = TstData[i].In16A;
			In16[1] = TstData[i].In16B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtImm16																		*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt16[j];
				Reg16[0] = In16[0];
				IxLmtImm16( &Reg16[0], LmtIn );
				x = LPX_ABS( (LONG)LmtIn );
				y = LPX_ABS( (LONG)In16[0] );
				z = LPX_ABS( (LONG)Reg16[0] );
			/*--------------------------------------------------------------------------------------*/
				if( z > x ){ TstNgCnt++;}
				if( (LmtIn == 0) && (Reg16[0] != 0) ){ TstNgCnt++;}
				if( (LmtIn != 0) && ((Reg16[0] ^ In16[0]) & 0x8000) ){ TstNgCnt++;}
				if( y > x ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else	   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtReg16																		*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt16[j];
				IxLmtReg16( &Reg16[0], In16[0], LmtIn );
				x = LPX_ABS( (LONG)LmtIn );
				y = LPX_ABS( (LONG)In16[0] );
				z = LPX_ABS( (LONG)Reg16[0] );
			/*--------------------------------------------------------------------------------------*/
				if( z > x ){ TstNgCnt++;}
				if( (LmtIn == 0) && (Reg16[0] != 0) ){ TstNgCnt++;}
				if( (LmtIn != 0) && ((Reg16[0] ^ In16[0]) & 0x8000) ){ TstNgCnt++;}
				if( y > x ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else	   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtCBR16																		*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt16[j];
				Flag.Carry = 0; Flag.Borrow = 0; FlagX = Flag;
				IxLmtCBR16( &Reg16[0], LmtIn );
				if( (FlagX.Carry == 1) && (Reg16[0] != 32767) ){ TstNgCnt++;}
				if( (FlagX.Carry == 0) && (FlagX.Borrow == 1) && (Reg16[0] != -32767) ){ TstNgCnt++;}
				if( (FlagX.Carry == 0) && (LmtIn ==   -32768) && (Reg16[0] != -32767) ){ TstNgCnt++;}
				if( LPX_CHK_LMTCBR16( LmtIn ) ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else						   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			/*--------------------------------------------------------------------------------------*/
				LmtIn = TstLmt16[j];
				Flag.Carry = 1; Flag.Borrow = 0; FlagX = Flag;
				IxLmtCBR16( &Reg16[0], LmtIn );
				if( (FlagX.Carry == 1) && (Reg16[0] != 32767) ){ TstNgCnt++;}
				if( (FlagX.Carry == 0) && (FlagX.Borrow == 1) && (Reg16[0] != -32767) ){ TstNgCnt++;}
				if( (FlagX.Carry == 0) && (LmtIn ==   -32768) && (Reg16[0] != -32767) ){ TstNgCnt++;}
				if( (FlagX.Carry == 1) || (FlagX.Borrow == 1) || (LmtIn ==  -32768) )
				if( LPX_CHK_LMTCBR16( LmtIn ) ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else						   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			/*--------------------------------------------------------------------------------------*/
				LmtIn = TstLmt16[j];
				Flag.Carry = 0; Flag.Borrow = 1; FlagX = Flag;
				IxLmtCBR16( &Reg16[0], LmtIn );
				if( (FlagX.Carry == 1) && (Reg16[0] != 32767) ){ TstNgCnt++;}
				if( (FlagX.Carry == 0) && (FlagX.Borrow == 1) && (Reg16[0] != -32767) ){ TstNgCnt++;}
				if( (FlagX.Carry == 0) && (LmtIn ==   -32768) && (Reg16[0] != -32767) ){ TstNgCnt++;}
				if( (FlagX.Carry == 1) || (FlagX.Borrow == 1) || (LmtIn ==  -32768) )
				if( LPX_CHK_LMTCBR16( LmtIn ) ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else						   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtzImm16																	*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt16[j];
				Reg16[0] = In16[0];
				IxLmtzImm16( &Reg16[0], LmtIn );
				x = LPX_ABS( (LONG)LmtIn );
				y = LPX_ABS( (LONG)In16[0] );
				z = LPX_ABS( (LONG)Reg16[0] );
			/*--------------------------------------------------------------------------------------*/
				if( (In16[0] ^ LmtIn) & 0x8000 )
				{
					if( Reg16[0] != 0 ){ TstNgCnt++;}
					if( Flag.Limit == 0 ){ TstNgCnt++;}
				}
				else
				{
					if( z > x ){ TstNgCnt++;}
					if( (LmtIn == 0) && (Reg16[0] != 0) ){ TstNgCnt++;}
					if( (LmtIn != 0) && ((Reg16[0] ^ In16[0]) & 0x8000) ){ TstNgCnt++;}
					if( y > x ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
					else	   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
				}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtzReg16																	*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt16[j];
				IxLmtzReg16( &Reg16[0], In16[0], LmtIn );
				x = LPX_ABS( (LONG)LmtIn );
				y = LPX_ABS( (LONG)In16[0] );
				z = LPX_ABS( (LONG)Reg16[0] );
			/*--------------------------------------------------------------------------------------*/
				if( (In16[0] ^ LmtIn) & 0x8000 )
				{
					if( Reg16[0] != 0 ){ TstNgCnt++;}
					if( Flag.Limit == 0 ){ TstNgCnt++;}
				}
				else
				{
					if( z > x ){ TstNgCnt++;}
					if( (LmtIn == 0) && (Reg16[0] != 0) ){ TstNgCnt++;}
					if( (LmtIn != 0) && ((Reg16[0] ^ In16[0]) & 0x8000) ){ TstNgCnt++;}
					if( y > x ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
					else	   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
				}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt != 0 )
		{
			printf( "\nTstIxInstLimit16() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
		printf( "\nTstIxInstLimit16() : Complete" );
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Limit Instructions : IxLmtXxx32, IxLmtCBR32, IxLmtzXxx32, etc							*/
/*																									*/
/****************************************************************************************************/
#define LPX_CHK_LMTCBR32( x )	(FlagX.Carry || FlagX.Borrow || (x == 0x80000000))
const	LONG	TstLmt32[] = { 0, 100, 1000, 0x7FFFFFFF, -100, -1000, 0x80000001, 0x80000000 };
/*--------------------------------------------------------------------------------------------------*/
LONG	TstIxInstLimit32( void )
{
LONG	i,j;
INT64	x,y,z;
FLAG	FlagX;
LONG	LmtIn;
LONG	In32[2];
LONG	Reg32[2];
LONG	TstNgCnt = 0;
LONG	TstDatNum = sizeof(TstData) / sizeof(TstData[0]);
LONG	TstLmtNum = sizeof(TstLmt32) / sizeof(TstLmt32[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Test IxLmtXxx32																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			In32[0] = TstData[i].In32A;
			In32[1] = TstData[i].In32B;
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtImm32																		*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt32[j];
				Reg32[0] = In32[0];
				IxLmtImm32( &Reg32[0], LmtIn );
				x = LPX_ABS( (INT64)LmtIn );
				y = LPX_ABS( (INT64)In32[0] );
				z = LPX_ABS( (INT64)Reg32[0] );
			/*--------------------------------------------------------------------------------------*/
				if( z > x ){ TstNgCnt++;}
				if( (LmtIn == 0) && (Reg32[0] != 0) ){ TstNgCnt++;}
				if( (LmtIn != 0) && ((Reg32[0] ^ In32[0]) & 0x80000000) ){ TstNgCnt++;}
				if( y > x ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else	   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtReg32																		*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt32[j];
				IxLmtReg32( &Reg32[0], In32[0], LmtIn );
				x = LPX_ABS( (INT64)LmtIn );
				y = LPX_ABS( (INT64)In32[0] );
				z = LPX_ABS( (INT64)Reg32[0] );
			/*--------------------------------------------------------------------------------------*/
				if( z > x ){ TstNgCnt++;}
				if( (LmtIn == 0) && (Reg32[0] != 0) ){ TstNgCnt++;}
				if( (LmtIn != 0) && ((Reg32[0] ^ In32[0]) & 0x80000000) ){ TstNgCnt++;}
				if( y > x ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else	   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtCBR32																		*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt32[j];
				Flag.Carry = 0; Flag.Borrow = 0; FlagX = Flag;
				IxLmtCBR32( &Reg32[0], LmtIn );
				if( (FlagX.Carry==1) && (Reg32[0]!=0x7FFFFFFF) ){ TstNgCnt++;}
				if( (FlagX.Carry==0) && (FlagX.Borrow == 1) && (Reg32[0]!=-0x7FFFFFFF) ){ TstNgCnt++;}
				if( (FlagX.Carry==0) && (LmtIn==0x80000000) && (Reg32[0]!=-0x7FFFFFFF) ){ TstNgCnt++;}
				if( LPX_CHK_LMTCBR32( LmtIn ) ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else						   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			/*--------------------------------------------------------------------------------------*/
				LmtIn = TstLmt32[j];
				Flag.Carry = 1; Flag.Borrow = 0; FlagX = Flag;
				IxLmtCBR32( &Reg32[0], LmtIn );
				if( (FlagX.Carry==1) && (Reg32[0]!=0x7FFFFFFF) ){ TstNgCnt++;}
				if( (FlagX.Carry==0) && (FlagX.Borrow == 1) && (Reg32[0]!=-0x7FFFFFFF) ){ TstNgCnt++;}
				if( (FlagX.Carry==0) && (LmtIn==0x80000000) && (Reg32[0]!=-0x7FFFFFFF) ){ TstNgCnt++;}
				if( LPX_CHK_LMTCBR32( LmtIn ) ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else						   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			/*--------------------------------------------------------------------------------------*/
				LmtIn = TstLmt32[j];
				Flag.Carry = 0; Flag.Borrow = 1; FlagX = Flag;
				IxLmtCBR32( &Reg32[0], LmtIn );
				if( (FlagX.Carry==1) && (Reg32[0]!=0x7FFFFFFF) ){ TstNgCnt++;}
				if( (FlagX.Carry==0) && (FlagX.Borrow == 1) && (Reg32[0]!=-0x7FFFFFFF) ){ TstNgCnt++;}
				if( (FlagX.Carry==0) && (LmtIn==0x80000000) && (Reg32[0]!=-0x7FFFFFFF) ){ TstNgCnt++;}
				if( LPX_CHK_LMTCBR32( LmtIn ) ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
				else						   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtzImm32																	*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt32[j];
				Reg32[0] = In32[0];
				IxLmtzImm32( &Reg32[0], LmtIn );
				x = LPX_ABS( (INT64)LmtIn );
				y = LPX_ABS( (INT64)In32[0] );
				z = LPX_ABS( (INT64)Reg32[0] );
			/*--------------------------------------------------------------------------------------*/
				if( (In32[0] ^ LmtIn) & 0x80000000 )
				{
					if( Reg32[0] != 0 ){ TstNgCnt++;}
					if( Flag.Limit == 0 ){ TstNgCnt++;}
				}
				else
				{
					if( z > x ){ TstNgCnt++;}
					if( (LmtIn == 0) && (Reg32[0] != 0) ){ TstNgCnt++;}
					if( (LmtIn != 0) && ((Reg32[0] ^ In32[0]) & 0x80000000) ){ TstNgCnt++;}
					if( y > x ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
					else	   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
				}
			}
		/*------------------------------------------------------------------------------------------*/
		/*		Test IxLmtzReg32																	*/
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < TstLmtNum; j++ )
			{
				LmtIn = TstLmt32[j];
				IxLmtzReg32( &Reg32[0], In32[0], LmtIn );
				x = LPX_ABS( (INT64)LmtIn );
				y = LPX_ABS( (INT64)In32[0] );
				z = LPX_ABS( (INT64)Reg32[0] );
			/*--------------------------------------------------------------------------------------*/
				if( (In32[0] ^ LmtIn) & 0x80000000 )
				{
					if( Reg32[0] != 0 ){ TstNgCnt++;}
					if( Flag.Limit == 0 ){ TstNgCnt++;}
				}
				else
				{
					if( z > x ){ TstNgCnt++;}
					if( (LmtIn == 0) && (Reg32[0] != 0) ){ TstNgCnt++;}
					if( (LmtIn != 0) && ((Reg32[0] ^ In32[0]) & 0x80000000) ){ TstNgCnt++;}
					if( y > x ){ if( Flag.Limit == 0 ){ TstNgCnt++;}}
					else	   { if( Flag.Limit == 1 ){ TstNgCnt++;}}
				}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt != 0 )
		{
			printf( "\nTstIxInstLimit32() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
		printf( "\nTstIxInstLimit32() : Complete" );
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		定数テーブル																				*/
/*																									*/
/****************************************************************************************************/
const SHORT TstMpTable[][2] = {
	{ 0x0000, 0x0001 }, { 0x0002, 0x0003 }, { 0x0004, 0x0005 }, { 0x0006, 0x0007 },
	{ 0x0008, 0x0009 }, { 0x000A, 0x000B }, { 0x000C, 0x000D }, { 0x000E, 0x000F },
	{ 0x0000, 0x1111 }, { 0x2222, 0x3333 }, { 0x4444, 0x5555 }, { 0x6666, 0x7777 },
	{ 0x8888, 0x9999 }, { 0xAAAA, 0xBBBB }, { 0xCCCC, 0xDDDD }, { 0xEEEE, 0xFFFF },
};



/****************************************************************************************************/
/*																									*/
/*		Test Read RomTable Instructions : IxTblSin16, IxTblVlmt16, etc								*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstTable16( void )
{
LONG	i;
SHORT	x,Idx;
LONG	TstNgCnt = 0;

/*--------------------------------------------------------------------------------------------------*/
/*		Test Read RomTable																			*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < 16; i++ )
		{
			IxTblSin16(    &x, (SHORT)i ); if( x != RomSinTable[i]    ){ TstNgCnt++;}
			IxTblAtan16(   &x, (SHORT)i ); if( x != RomAtanTable[i]   ){ TstNgCnt++;}
			IxTblSqrt16(   &x, (SHORT)i ); if( x != RomRootTable[i]   ){ TstNgCnt++;}
			IxTblVlmt16(   &x, (SHORT)i ); if( x != RomVlmtTableXX[i] ){ TstNgCnt++;}
			IxTblSpvect16( &x, (SHORT)i ); if( x != RomSpvectTable[i] ){ TstNgCnt++;}
			IxTblMatcon16( &x, (SHORT)i ); if( x != RomMatconTable[i] ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Test IxLoadMpmem16																			*/
/*--------------------------------------------------------------------------------------------------*/
		IxSetCtblAdr( &Idx, &TstMpTable[0][0] );
		for( i=0; i < 16; i++, Idx++ )
		{
			IxLoadMpmem16( &x, Idx, 0 );
			if( x != TstMpTable[i][0] ){ TstNgCnt++;}
			IxLoadMpmem16( &x, Idx, 1 );
			if( x != TstMpTable[i][1] ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt != 0 )
		{
			printf( "\nTstIxInstTable16() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
		printf( "\nTstIxInstTable16() : Complete" );
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Other Instructions																		*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstOther16( void )
{
LONG	i;
LONG	TstOkCnt = 0;
LONG	TstNgCnt = 0;

/*--------------------------------------------------------------------------------------------------*/
/*		Test Etc																					*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < 10; i++ )
		{
			IxNop( );
			if( 0 ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt != 0 )
		{
			printf( "\nTstIxInstOther16() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstOkCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( TstOkCnt >  0 )
		{
			printf( "\nTstIxInstOther16() : Complete" );
		}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
/*--------------------------------------------------------------------------------------------------*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Other Instructions																		*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstOther32( void )
{
LONG	i;
LONG	TstOkCnt = 0;
LONG	TstNgCnt = 0;

/*--------------------------------------------------------------------------------------------------*/
/*		Test Etc																					*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < 10; i++ )
		{
			IxNop( );
			if( 0 ){ TstNgCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt != 0 )
		{
			printf( "\nTstIxInstOther32() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstOkCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( TstOkCnt >  0 )
		{
			printf( "\nTstIxInstOther32() : Complete" );
		}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
/*--------------------------------------------------------------------------------------------------*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test MulgainXX Instructions : IxMulgain, IxMulgain27, IxMulgain30, etc						*/
/*																									*/
/****************************************************************************************************/
const	LONG	TdatMulgainXX[][4] = {
/*--------------------------------------------------------------------------------------------------*/
/*		u			kx			sx		-															*/
/*--------------------------------------------------------------------------------------------------*/
		0x00000000,	0x00000000,	 0,		0,			/* Mulgain   : Input = 0, Gain = 0				*/
		0x00000000,	0x00000001,	 0,		0,			/* Mulgain   : Input = 0, Gain = 1				*/
		0x00000001,	0x00000000,	 0,		0,			/* Mulgain   : Input = 1, Gain = 0				*/
		0x00000001,	0x00000001,	 0,		0,			/* Mulgain   : Input = 1, Gain = 1				*/
/*--------------------------------------------------------------------------------------------------*/
		0x00000001,	0x00000001,	 1,		0,			/* Mulgain   : Normal Calc. Sx = 1				*/
		0x00000022,	0x00000022,	 2,		0,			/* Mulgain   : Normal Calc. Sx = 2				*/
		0x00000333,	0x00000333,	 4,		0,			/* Mulgain   : Normal Calc. Sx = 4				*/
		0x00004444,	0x00004444,	 8,		0,			/* Mulgain   : Normal Calc. Sx = 8				*/
		0x00005555,	0x00055555,	12,		0,			/* Mulgain   : Normal Calc. Sx = 12				*/
		0x00066666,	0x00066666,	16,		0,			/* Mulgain   : Normal Calc. Sx = 16				*/
		0x00777777,	0x00077777,	20,		0,			/* Mulgain   : Normal Calc. Sx = 20				*/
		0x01FFFFFF,	0x00777777,	24,		0,			/* Mulgain   : Normal Calc. Sx = 24				*/
/*--------------------------------------------------------------------------------------------------*/
		0x00111111,	0x0000000F,	 1,		0,			/* Mulgain   : Normal Calc. Round up			*/
		0x00222222, 0x0000000F,  2,		0,			/* Mulgain   : Normal Calc. Round up			*/
		0x00111110, 0x0000000F,  5,		0,			/* Mulgain   : Normal Calc. Round up			*/
		0x00111100, 0x0000000F,  9,		0,			/* Mulgain   : Normal Calc. Round up			*/
		0x00111000, 0x0000000F, 13,		0,			/* Mulgain   : Normal Calc. Round up			*/
		0x00110000, 0x0000000F, 17,		0,			/* Mulgain   : Normal Calc. Round up			*/
		0x01100000, 0x0000000F, 21,		0,			/* Mulgain   : Normal Calc. Round up			*/
		0x08800000, 0x0000000F, 24,		0,			/* Mulgain   : Normal Calc. Round up			*/
/*--------------------------------------------------------------------------------------------------*/
		0x00000001, 0x00000001, 24,		0,			/* Mulgain   : Small Gain = 1 / 2^24			*/
		0x0000FFFF, 0x00000001, 24,		0,			/* Mulgain   : Small Gain = 1 / 2^24			*/
		0x007FFFFF, 0x00000001, 24,		0,			/* Mulgain   : Small Gain = 1 / 2^24			*/
		0x00800000, 0x00000001, 24,		0,			/* Mulgain   : Small Gain = 1 / 2^24			*/
		0x00FFFFFF, 0x00000001, 24,		0,			/* Mulgain   : Small Gain = 1 / 2^24			*/
		0x0FFFFFFF, 0x00000001, 24,		0,			/* Mulgain   : Small Gain = 1 / 2^24			*/
		0x7FFFFFFF, 0x00000001, 24,		0,			/* Mulgain   : Small Gain = 1 / 2^24			*/
		0x80000000, 0x00000001, 24,		0,			/* Mulgain   : Small Gain = 1 / 2^24			*/
/*--------------------------------------------------------------------------------------------------*/
		0x00FFFFFD, 0x00000001,  0,		0,			/* Mulgain   : Near Limit ( 0x00FFFFFD + 0.00 )	*/
		0x00FFFFFE, 0x00000001,  0,		0,			/* Mulgain   : Near Limit ( 0x00FFFFFE + 0.00 ) */
		0x00FFFFFF, 0x00000001,  0,		0,			/* Mulgain   : Near Limit ( 0x00FFFFFF + 0.00 ) */
		0x01000000, 0x00000001,  0,		0,			/* Mulgain   : Near Limit ( 0x01000000 + 0.00 ) */
		0x01000001, 0x00000001,  0,		0,			/* Mulgain   : Near Limit ( 0x01000001 + 0.00 ) */
		0x01000002, 0x00000001,  0,		0,			/* Mulgain   : Near Limit ( 0x01000002 + 0.00 ) */
/*--------------------------------------------------------------------------------------------------*/
		0x0FFFFFF7, 0x00000010,  8,		0,			/* Mulgain   : Near Limit ( 0x00FFFFFF + 0.44 )	*/
		0x0FFFFFF8, 0x00000010,  8,		0,			/* Mulgain   : Near Limit ( 0x00FFFFFF + 0.50 ) */
		0x0FFFFFF9, 0x00000010,  8,		0,			/* Mulgain   : Near Limit ( 0x00FFFFFF + 0.56 ) */
		0x10000000, 0x00000010,  8,		0,			/* Mulgain   : Near Limit ( 0x01000000 + 0.00 ) */
		0x10000001, 0x00000010,  8,		0,			/* Mulgain   : Near Limit ( 0x01000000 + 0.06 ) */
		0x10000002, 0x00000010,  8,		0,			/* Mulgain   : Near Limit ( 0x01000000 + 0.13 ) */
/*--------------------------------------------------------------------------------------------------*/
		0x0FFFFFF7, 0x00100000, 24,		0,			/* Mulgain   : Near Limit ( 0x00FFFFFF + 0.44 )	*/
		0x0FFFFFF8, 0x00100000, 24,		0,			/* Mulgain   : Near Limit ( 0x00FFFFFF + 0.50 ) */
		0x0FFFFFF9, 0x00100000, 24,		0,			/* Mulgain   : Near Limit ( 0x00FFFFFF + 0.56 ) */
		0x10000000, 0x00100000, 24,		0,			/* Mulgain   : Near Limit ( 0x01000000 + 0.00 ) */
		0x10000001, 0x00100000, 24,		0,			/* Mulgain   : Near Limit ( 0x01000000 + 0.06 ) */
		0x10000002, 0x00100000, 24,		0,			/* Mulgain   : Near Limit ( 0x01000000 + 0.13 ) */
/*--------------------------------------------------------------------------------------------------*/
		0x7FFFFFFF, 0x007FFFFF,  0,		0,			/* Max.Input : Over Limit ( > 2^31 )			*/
		0x80000000, 0x007FFFFF,  0,		0,			/* Max.Input : Over Limit ( > 2^31 )			*/
		0x7FFFFFFF, 0x007FFFFF,  8,		0,			/* Max.Input : Over Limit ( > 2^31 )			*/
		0x80000000, 0x007FFFFF,  8,		0,			/* Max.Input : Over Limit ( > 2^31 )			*/
		0x7FFFFFFF, 0x007FFFFF, 16,		0,			/* Max.Input : Over Limit ( > 2^31 )			*/
		0x80000000, 0x007FFFFF, 16,		0,			/* Max.Input : Over Limit ( > 2^31 )			*/
		0x7FFFFFFF, 0x007FFFFF, 24,		0,			/* Max.Input : Over Limit ( 0x3FFFFF7F + 0.50 )	*/
		0x80000000, 0x007FFFFF, 24,		0,			/* Max.Input : Over Limit ( 0x3FFFFF80 + 0.00 )	*/
/*--------------------------------------------------------------------------------------------------*/
		0x03FFFFFE, 0x00000001,	 0,		0,			/* Mulgain27 : Near Limit ( 0x03FFFFFE + 0.00 )	*/
		0x03FFFFFF, 0x00000001,	 0,		0,			/* Mulgain27 : Near Limit ( 0x03FFFFFF + 0.00 )	*/
		0x04000000, 0x00000001,	 0,		0,			/* Mulgain27 : Near Limit ( 0x04000000 + 0.00 ) */
		0x04000001, 0x00000001,	 0,		0,			/* Mulgain27 : Near Limit ( 0x04000001 + 0.00 )	*/
		0x3FFFFFFF,	0x00000001,	 4,		0,			/* Mulgain27 : Near Limit ( 0x03FFFFFF + 0.93 ) */
		0x40000000,	0x00000001,	 4,		0,			/* Mulgain27 : Near Limit ( 0x04000000 + 0.00 ) */
		0x40000001, 0x00000001,	 4,		0,			/* Mulgain27 : Near Limit ( 0x04000000 + 0.06 ) */
		0x40000002, 0x00000001,	 4,		0,			/* Mulgain27 : Near Limit ( 0x04000000 + 0.12 ) */
/*--------------------------------------------------------------------------------------------------*/
		0x0FFFFFFE, 0x00000001,	 0,		0,			/* Mulgain29 : Near Limit ( 0x0FFFFFFE + 0.00 )	*/
		0x0FFFFFFF, 0x00000001,	 0,		0,			/* Mulgain29 : Near Limit ( 0x0FFFFFFF + 0.00 )	*/
		0x10000000, 0x00000001,	 0,		0,			/* Mulgain29 : Near Limit ( 0x10000000 + 0.00 ) */
		0x10000001, 0x00000001,	 0,		0,			/* Mulgain29 : Near Limit ( 0x10000001 + 0.00 )	*/
		0x7FFFFFF8,	0x00000001,	 3,		0,			/* Mulgain29 : Near Limit ( 0x0FFFFFFF + 0.00 ) */
		0x7FFFFFFF,	0x00000001,	 3,		0,			/* Mulgain29 : Near Limit ( 0x0FFFFFFF + 0.88 ) */
		0x08000000, 0x00000010,	 3,		0,			/* Mulgain29 : Near Limit ( 0x10000000 + 0.00 ) */
		0x08000001, 0x00000010,	 3,		0,			/* Mulgain29 : Near Limit ( 0x10000002 + 0.00 ) */
/*--------------------------------------------------------------------------------------------------*/
		0x1FFFFFFE, 0x00000001,	 0,		0,			/* Mulgain30 : Near Limit ( 0x1FFFFFFE + 0.00 ) */
		0x1FFFFFFF, 0x00000001,	 0,		0,			/* Mulgain30 : Near Limit ( 0x1FFFFFFF + 0.00 ) */
		0x20000000, 0x00000001,	 0,		0,			/* Mulgain30 : Near Limit ( 0x20000001 + 0.00 ) */
		0x20000001, 0x00000001,	 0,		0,			/* Mulgain30 : Near Limit ( 0x20000002 + 0.00 ) */
		0x7FFFFFFC,	0x00000001,	 2,		0,			/* Mulgain30 : Near Limit ( 0x1FFFFFFF + 0.00 ) */
		0x7FFFFFFF,	0x00000001,	 2,		0,			/* Mulgain30 : Near Limit ( 0x1FFFFFFF + 0.75 ) */
		0x08000000, 0x00000010,	 2,		0,			/* Mulgain30 : Near Limit ( 0x20000000 + 0.00 ) */
		0x08000001, 0x00000010,	 2,		0,			/* Mulgain30 : Near Limit ( 0x20000004 + 0.00 ) */
/*--------------------------------------------------------------------------------------------------*/
		0x7FFFFFFE, 0x00000001,	 0,		0,			/* MulGain32 : Near Limit ( 0x7FFFFFFE + 0.00 ) */
		0x7FFFFFFF, 0x00000001,	 0,		0,			/* MulGain32 : Near Limit ( 0x7FFFFFFF + 0.00 ) */
		0x80000000, 0x00000001,	 0,		0,			/* MulGain32 : Near Limit ( 0x80000000 + 0.00 ) */
		0x7FFFFFFF, 0x00000002,	 1,		0,			/* MulGain32 : Near Limit ( 0x7FFFFFFF + 0.00 ) */
		0x80000000, 0x00000002,	 1,		0,			/* MulGain32 : Near Limit ( 0x80000000 + 0.00 ) */
		0x3FFFFFFF, 0x00000010,	 3,		0,			/* MulGain32 : Near Limit ( 0x7FFFFFFE + 0.00 ) */
		0x40000000, 0x00000010,	 3,		0,			/* MulGain32 : Near Limit ( 0x80000000 + 0.00 ) */
		0x40000001, 0x00000010,	 3,		0,			/* MulGain32 : Near Limit ( 0x80000002 + 0.00 ) */
/*--------------------------------------------------------------------------------------------------*/
};
/****************************************************************************************************/
/*		Test Function																				*/
/****************************************************************************************************/
LONG	TstIxInstMulgainXX( void )
{
LONG	i,j;
DWREG	wk[4];
LONG	x[8],u;
LONG	ks,kx,sx;
double	rk,fx[8];
double	rx,fer[8];
LONG	TstOkCnt = 0;
LONG	TstNgCnt = 0;
LONG	TstDatNum = sizeof(TdatMulgainXX) / sizeof(TdatMulgainXX[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Test Loop																					*/
/*--------------------------------------------------------------------------------------------------*/
		for( j=0; j < 4; j++ )
		{
			for( i=0; i < TstDatNum; i++ )
			{
				u  = TdatMulgainXX[i][0];
				kx = TdatMulgainXX[i][1];
				sx = TdatMulgainXX[i][2];
			/*--------------------------------------------------------------------------------------*/
				switch( j )
				{
				case 0: break;
				case 1: u  = -u;  break;
				case 2: kx = -kx; break;
				case 3: u  = -u;  kx = -kx; break;
				}
			/*--------------------------------------------------------------------------------------*/
				ks = (kx & 0xFFFFFF) + (sx<<24);
				rk = (double)kx / pow(2.0, sx);
			/*--------------------------------------------------------------------------------------*/
				rx = rk * (double)u;
				fx[0] = LPX_LIMIT( rx, 0x01000000 );
				fx[1] = LPX_LIMIT( rx, 0x04000000 );
				fx[2] = LPX_LIMIT( rx, 0x0FFFFFFF );
				fx[3] = LPX_LIMIT( rx, 0x1FFFFFFF );
				fx[4] = LPX_LIMIT( rx, 0x7FFFFFFF );
			/*--------------------------------------------------------------------------------------*/
				IxMulgain( &x[0], u, ks, wk );
				fer[0] = fx[0] - (double)x[0];
				if( fabs( fer[0] ) > 0.5 ){ TstNgCnt++;} else { TstOkCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxMulgain27( &x[1], u, ks, wk );
				fer[1] = fx[1] - (double)x[1];
				if( fabs( fer[1] ) > 0.5 ){ TstNgCnt++;} else { TstOkCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxMulgain29( &x[2], u, ks, wk );
				fer[2] = fx[2] - (double)x[2];
				if( fabs( fer[2] ) > 0.5 ){ TstNgCnt++;} else { TstOkCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxMulgain30( &x[3], u, ks, wk );
				fer[3] = fx[3] - (double)x[3];
				if( fabs( fer[3] ) > 0.5 ){ TstNgCnt++;} else { TstOkCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxMulgain32( &x[4], u, ks, wk );
				fer[4] = fx[4] - (double)x[4];
				if( fabs( fer[4] ) > 0.5 ){ TstNgCnt++;} else { TstOkCnt++;}
			/*--------------------------------------------------------------------------------------*/
				IxMulgainNolim( &x[5], u, ks, wk );
				fer[5] = rx - (double)x[5];
				if( (rx < (LONG)0x7FFFFFFF) && (rx > (LONG)0x80000000) )
				{
					if( fabs( fer[5] ) > 0.5 ){ TstNgCnt++;} else { TstOkCnt++;}
				}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt == 0 )
		{
			printf( "\nTstIxInstMulgainXX() : Complete" );
		}
		else
		{
			printf( "\nTstIxInstMulgainXX() : Error" );
			return( TSTNG );
		}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
/*--------------------------------------------------------------------------------------------------*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Mulhigh32 Instruction																	*/
/*																									*/
/****************************************************************************************************/
const	LONG	TdatMulhigh32[][4] = {
/*--------------------------------------------------------------------------------------------------*/
/*		 a				 b				spare0		spare1											*/
/*--------------------------------------------------------------------------------------------------*/
		 0,				 0,				0,			0,			/*									*/
		 1,				 0,				0,			0,			/*									*/
		 0,				 1,				0,			0,			/*									*/
		 1,				 1,				0,			0,			/*									*/
		-1,				 1,				0,			0,			/*									*/
		 1,				-1,				0,			0,			/*									*/
		-1,				-1,				0,			0,			/*									*/
/*--------------------------------------------------------------------------------------------------*/
		 123456,		 456789,		0,			0,			/*									*/
		-123456,		 456789,		0,			0,			/*									*/
		 123456,		-456789,		0,			0,			/*									*/
		-123456,		-456789,		0,			0,			/*									*/
/*--------------------------------------------------------------------------------------------------*/
		 1,				 3840000,		0,			0,			/*									*/
		-1,				 3840000,		0,			0,			/*									*/
		 1118,			 3840000,		0,			0,			/*									*/
		-1118,			 3840000,		0,			0,			/*									*/
		 0x01000000,	 3840000,		0,			0,			/*  0x01000000 --> 15000			*/
		-0x01000000,	 3840000,		0,			0,			/* -0x01000000 --> 15000			*/
/*--------------------------------------------------------------------------------------------------*/
		 1,				 73300775,		0,			0,			/*									*/
		-1,				 73300775,		0,			0,			/*									*/
		 65536,			 73300775,		0,			0,			/*  1 -->  0x01000000/15000			*/
		-65536,			 73300775,		0,			0,			/* -1 --> -0x01000000/15000			*/
		 983040000,		 73300775,		0,			0,			/*  15000 -->  0x01000000			*/
		-983040000,		 73300775,		0,			0,			/* -15000 --> -0x01000000			*/
/*--------------------------------------------------------------------------------------------------*/
		0x11111111,		0x11111111,		0,			0,			/* Mulhighu32						*/
		0x33333333,		0x33333333,		0,			0,			/* Mulhighu32						*/
		0x55555555,		0x55555555,		0,			0,			/* Mulhighu32						*/
		0x77777777,		0x77777777,		0,			0,			/* Mulhighu32						*/
		0x7FFFFFFF,		0x7FFFFFFF,		0,			0,			/* Mulhighu32						*/
		0x80000000,		0x80000000,		0,			0,			/* Mulhighu32						*/
		0xCCCCCCCC,		0xCCCCCCCC,		0,			0,			/* Mulhighu32						*/
		0xFFFFFFFF,		0xFFFFFFFF,		0,			0,			/* Mulhighu32						*/
/*--------------------------------------------------------------------------------------------------*/
};
/****************************************************************************************************/
/*		Test Function																				*/
/****************************************************************************************************/
LONG	TstIxInstMulhigh32( void )
{
LONG	i;
LONG	a,b,x;
double	fx,fer;
LONG	TstOkCnt = 0;
LONG	TstNgCnt = 0;
LONG	TstDatNum = sizeof(TdatMulhigh32) / sizeof(TdatMulhigh32[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Test Loop																					*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			a = TdatMulhigh32[i][0];
			b = TdatMulhigh32[i][1];
		/*------------------------------------------------------------------------------------------*/
			IxMulhigh32( &x, a, b );
			fx = (double)a * (double)b / 4294967296.0;
		/*------------------------------------------------------------------------------------------*/
			fer = fx - (double)x;
			if( fabs( fer ) > 0.5 ){ TstNgCnt++;} else { TstOkCnt++;}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt == 0 )
		{
			printf( "\nTstIxInstMulhigh32() : Complete" );
		}
		else
		{
			printf( "\nTstIxInstMulhigh32() : Error" );
			return( TSTNG );
		}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
/*--------------------------------------------------------------------------------------------------*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Integral Instruction																	*/
/*																									*/
/****************************************************************************************************/
const	LONG	TdatIntegral[][4] = {
/*--------------------------------------------------------------------------------------------------*/
/*		  u				  kx			sx		Repeat												*/
/*--------------------------------------------------------------------------------------------------*/
		0x00000000,		0x00000000,		 0,		0,				/* Input = 0, Gain = 0				*/
		0x00000000,		0x00000001,		 0,		0,				/* Input = 0, Gain = 1				*/
		0x00000001,		0x00000000,		 0,		0,				/* Input = 1, Gain = 0				*/
		0x00000001,		0x00000001,		 0,		0,				/* Input = 1, Gain = 1				*/
/*--------------------------------------------------------------------------------------------------*/
		0x00000001,		0x00000001,		 1,		0,				/* Normal Calc. Sx = 1				*/
		0x00000022,		0x00000022,		 2,		0,				/* Normal Calc. Sx = 2				*/
		0x00000333,		0x00000333,		 4,		0,				/* Normal Calc. Sx = 4				*/
		0x00004444,		0x00004444,		 8,		0,				/* Normal Calc. Sx = 8				*/
		0x00005555,		0x00055555,		12,		0,				/* Normal Calc. Sx = 12				*/
		0x00066666,		0x00066666,		16,		0,				/* Normal Calc. Sx = 16				*/
		0x00077777,		0x00077777,		20,		0,				/* Normal Calc. Sx = 20				*/
		0x00777777,		0x00777777,		24,		0,				/* Normal Calc. Sx = 24				*/
/*--------------------------------------------------------------------------------------------------*/
		0x00000001,		0x00000001,		24,		0,				/* Normal Calc.						*/
		0x00000333,		0x0000FFFF,		24,		0,				/* Normal Calc.						*/
		0x00055555,		0x000FFFFF,		24,		0,				/* Normal Calc.						*/
		0x00555555,		0x007FFFFF,		24,		0,				/* Normal Calc.						*/
		0x007FFFFF,		0x007FFFFF,		24,		0,				/* Normal Calc.						*/
/*--------------------------------------------------------------------------------------------------*/
		0x00777777,		0x00000033,		12,		0,				/* Normal Calc.						*/
		0x00555555,		0x00000011,		16,		0,				/* Normal Calc.						*/
		0x00588888,		0x00000022,		20,		0,				/* Near Integral Limit : Near		*/
		0x00011111,		0x0000000F,		24,		16,				/* Near Integral Limit : Limit 		*/
/*--------------------------------------------------------------------------------------------------*/
	   -0x00011111,		0x0000000F,		24,		16,				/* Near Integral Limit : Decrease	*/
	   +0x00011111,		0x0000000F,		24,		32,				/* Near Integral Limit : Increase	*/
	   -0x00011111,		0x0000000F,		24,		16,				/* Near Integral Limit : Decrease	*/
	   +0x00011111,		0x0000000F,		24,		32,				/* Near Integral Limit : Increase	*/
/*--------------------------------------------------------------------------------------------------*/
	   -0x00000001,		0x007FFFFF,		 0,		0,				/* Large Gain : Near Limit			*/
	    0x00000002,		0x007FFFFF,		 0,		0,				/* Large Gain : Limit Integ.Input	*/
	   -0x00000003,		0x007FFFFF,		 0,		0,				/* Large Gain : Limit Integ.Input	*/
	    0x00000040,		0x007FFFFF,		 0,		0,				/* Large Gain : Limit Integ.Input	*/
	   -0x00000050,		0x007FFFFF,		 0,		0,				/* Large Gain : Limit Integ.Input	*/
/*--------------------------------------------------------------------------------------------------*/
	    0x01000000,		0x003FFFFF,		16,		0,				/* Large Input : Limit Integ.Input	*/
	   -0x01000000,		0x003FFFFF,		16,		0,				/* Large Input : Limit Integ.Input	*/
	    0x01000000,		0x003FFFFF,		16,		0,				/* Large Input : Limit Integ.Input	*/
	   -0x01000000,		0x003FFFFF,		16,		0,				/* Large Input : Limit Integ.Input	*/
	    0x01000000,		0x007FFFFF,		 0,		0,				/* Large Input : Limit Integ.Input	*/
	   -0x01000000,		0x007FFFFF,		 0,		0,				/* Large Input : Limit Integ.Input	*/
/*--------------------------------------------------------------------------------------------------*/
		0x00000001,		0x00000001,		 2,		0,				/* SymIntegral : X.25				*/
		0x00000003,		0x00000003,		 2,		0,				/* SymIntegral : X.50				*/
		0x00000005,		0x00000005,		 2,		0,				/* SymIntegral : X.75				*/
		0x00000007,		0x00000007,		 2,		0,				/* SymIntegral : X.00				*/
		0x00000009,		0x00000009,		 2,		0,				/* SymIntegral : X.25				*/
		0x0000000B,		0x0000000B,		 2,		0,				/* SymIntegral : X.50				*/
/*--------------------------------------------------------------------------------------------------*/
};
/****************************************************************************************************/
/*																									*/
/*		積分演算 : iu=iu+(kx*u); rv=((iu[1]+1)>>1);													*/
/*																									*/
/****************************************************************************************************/
LONG	ClibIntegral( LONG u, LONG k, LONG iu[2] )
{
LONG	x;
LONG	xx[2];
LONG	carry;
LONG	kx = (k<<8);
LONG	sx = (((ULONG)k)>>24);
#define	MUL3232( a, b, xx )		*(INT64*)xx = ((INT64)(a))*((INT64)(b))

/*--------------------------------------------------------------------------------------------------*/
/*		入力演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( u, kx, xx );
		x = (xx[1] >> sx);
/*--------------------------------------------------------------------------------------------------*/
/*		積分演算																					*/
/*--------------------------------------------------------------------------------------------------*/
		if( x > 0 )
		{
			iu[1] = iu[1] + (LONG)0x02000000;
		}
		else if( x < -1 )
		{
			iu[1] = iu[1] - (LONG)0x02000000;
		}
		else
		{
			carry = ( (ULONG)(iu[0]+(xx[0]<<(25-sx))) < (ULONG)iu[0] );
			iu[0] = iu[0] + (xx[0]<<(25-sx));
			iu[1] = iu[1] + (xx[1]<<(25-sx)) + (((ULONG)xx[0]>>sx)>>7) + carry;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		積分値リミット																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( iu[1] >= (LONG)0x02000000 )
		{
			iu[0] = 0;
			iu[1] = 0x02000000;
		}
		else if( iu[1] < (LONG)-0x02000000 )
		{
			iu[0] =  0;
			iu[1] = -0x02000000;
		}
/*--------------------------------------------------------------------------------------------------*/
/*		戻り値計算(四捨五入処理)																	*/
/*--------------------------------------------------------------------------------------------------*/
		return( ((iu[1]+1)>>1) );
}
/****************************************************************************************************/
/*																									*/
/*		Test Function																				*/
/*																									*/
/****************************************************************************************************/
LONG	TstIxInstIntegral( void )
{
LONG	i,j;
LONG	n,m;
LONG	u,ks;
LONG	kx,sx;
LONG	ix[4];
LONG	iy[4];
DWREG	wk[4];
double	fk,fku;
double	fix[2],fer[2];
LONG	TstOkCnt = 0;
LONG	TstNgCnt = 0;
LONG	TstDatNum = sizeof(TdatIntegral) / sizeof(TdatIntegral[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		数値演算ループ																				*/
/*--------------------------------------------------------------------------------------------------*/
		for( j=0; j<2; j++ )
		{
		    fix[0]=fix[1]=0;
			ix[0]=ix[1]=ix[2]=ix[3]=0;
			iy[0]=iy[1]=iy[2]=iy[3]=0;
		/*------------------------------------------------------------------------------------------*/
		    for( i=0; i<TstDatNum; i++ )
		    {
			/*--------------------------------------------------------------------------------------*/
				u  = TdatIntegral[i][0];
				kx = TdatIntegral[i][1];
				sx = TdatIntegral[i][2];
				m  = TdatIntegral[i][3];
				if( j == 1) u = -u;
			/*--------------------------------------------------------------------------------------*/
				ks = (kx&0xFFFFFF) + (sx<<24);
				fk = (double)kx / pow(2.0, sx);
				fku= fk * (double)u;
				if( fku >  16777216.0 ){ fku =  16777216.0;}
				if( fku < -16777216.0 ){ fku = -16777216.0;}
			/*--------------------------------------------------------------------------------------*/
				for( n=0; (n==0)||(n<m); n++ )
				{
					ix[0] = ClibIntegral( u, ks, &ix[2] );
					IxIntegral( &iy[0], u, ks, &iy[2], wk );
				/*----------------------------------------------------------------------------------*/
					fix[0] = fix[0] + fku;
					if( fix[0] >  16777216.0 ){ fix[0] =  16777216.0;}
					if( fix[0] < -16777216.0 ){ fix[0] = -16777216.0;}
					fix[1] = (double)(*(INT64*)&ix[2]) / pow( 2, 33 );
				/*----------------------------------------------------------------------------------*/
					fer[0] = fix[0] - (double)ix[0];
					fer[1] = fix[0] - fix[1];
					if( fabs( fer[0] ) > 0.5 ){ m = n; break;}
					if( fer[1] != 0.0        ){ m = n; break;}
				}
			/*--------------------------------------------------------------------------------------*/
				if( (ix[0] == iy[0]) && (ix[2] == iy[2]) && (ix[3] == iy[3]) )
				{
					TstOkCnt++;
				}
				else
				{
					TstNgCnt++;
				}
			/*--------------------------------------------------------------------------------------*/
				if( fer[1] != 0.0 )
				{
					TstNgCnt++;
				}
				if( fabs( fer[0] ) > 0.5 )
				{
					TstNgCnt++;
				}
		    }
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check TstNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( TstNgCnt == 0 )
		{
			printf( "\nTstIxInstIntegral()  : Complete" );
		}
		else
		{
			printf( "\nTstIxInstIntegral()  : Error" );
			return( TSTNG );
		}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
/*--------------------------------------------------------------------------------------------------*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Lpfilter1 Instruction																	*/
/*																									*/
/****************************************************************************************************/
const	LONG	TdatLpfilter1[][4] = {
/*--------------------------------------------------------------------------------------------------*/
/*		 u				k				spare0		spare1											*/
/*--------------------------------------------------------------------------------------------------*/
		 0,				0,				0,			0,			/*									*/
		 10000,			0,				0,			0,			/*									*/
/*--------------------------------------------------------------------------------------------------*/
		 10000,			0x00000001,		0,			0,			/*									*/
		 10000,			0x00000033,		0,			0,			/*									*/
		 10000,			0x00000333,		0,			0,			/*									*/
		 10000,			0x00003333,		0,			0,			/*									*/
		 10000,			0x00033333,		0,			0,			/*									*/
		 10000,			0x00333333,		0,			0,			/*									*/
		 10000,			0x00800000,		0,			0,			/*									*/
/*--------------------------------------------------------------------------------------------------*/
		 10000,			0x01000000,		0,			0,			/*									*/
/*--------------------------------------------------------------------------------------------------*/
};
/****************************************************************************************************/
/*		ローパスフィルタ : rv = x + ((kx*(u-x))>>24);												*/
/****************************************************************************************************/
LONG	ClibLpfilter1( LONG u, LONG k, LONG x )
{
LONG	wk1;
LONG	xx[2];
#define	MUL3232( a, b, xx )		*(INT64*)xx = ((INT64)(a))*((INT64)(b))
/*--------------------------------------------------------------------------------------------------*/
/*		ゲインチェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( k == 0 )
		{
			return( u );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		フィルタ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( (u-x), k, xx );
		wk1 = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);
/*--------------------------------------------------------------------------------------------------*/
		if( wk1 == 0 )
		{
			return( x + ((u-x)>0) - ((u-x)<0) );
		}
		else
		{
			return( x + wk1 );
		}
}
/****************************************************************************************************/
/*		ハイパスフィルタ : rv=u-z; z=z+((kx*(u-z))>>24);											*/
/****************************************************************************************************/
LONG	ClibHpfilter1( LONG u, LONG k, LONG *z )
{
LONG	wk1;
LONG	xx[2];
/*--------------------------------------------------------------------------------------------------*/
/*		ゲインチェック																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( k == 0 )
		{
			*z = 0;
			return( u );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		フィルタ演算																				*/
/*--------------------------------------------------------------------------------------------------*/
		MUL3232( (u-*z), k, xx );
		wk1 = (xx[1]<<8) + (((((ULONG)xx[0])>>23)+1)>>1);
/*--------------------------------------------------------------------------------------------------*/
		if( wk1 == 0 )
		{
			*z = *z + ((u-*z)>0) - ((u-*z)<0);
		}
		else
		{
			*z = *z + wk1;
		}
/*--------------------------------------------------------------------------------------------------*/
		return( u - *z );
}
/****************************************************************************************************/
/*		Test Function																				*/
/****************************************************************************************************/
LONG	TstIxInstLpfilter1( void )
{
LONG	i,j,m;
DWREG	wk[4];
LONG	u,k,x[2];
LONG	y[2],z[2];
LONG	LpfNgCnt = 0;
LONG	HpfNgCnt = 0;
LONG	TstDatNum = sizeof(TdatLpfilter1) / sizeof(TdatLpfilter1[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Test Loop																					*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i < TstDatNum; i++ )
		{
			u = TdatLpfilter1[i][0];
			k = TdatLpfilter1[i][1];
		/*------------------------------------------------------------------------------------------*/
			for( m=0; m < 2; m++ )
			{
				if( m == 1 ){ u = -u;}
				memset( x, 0x00, sizeof(x) );
				memset( y, 0x00, sizeof(y) );
				memset( z, 0x00, sizeof(z) );
			/*--------------------------------------------------------------------------------------*/
				for( j=0; j < 2000; j++ )
				{
					if( j == 1800 ){ x[0] = x[1] = u - 100;}
					if( j == 1900 ){ x[0] = x[1] = u + 100;}
				/*----------------------------------------------------------------------------------*/
					IxLpfilter1( &x[0], u, k, wk );
					x[1] = ClibLpfilter1( u, k, x[1] );
					if( x[0] != x[1] ){ LpfNgCnt++;}
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
					if( 0 ){ printf( "\nx[0]=%8d, x[1]=%8d", x[0], x[1] );}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
				}
			/*--------------------------------------------------------------------------------------*/
				for( j=0; j < 2000; j++ )
				{
					y[0] = 123; y[1] = 456;
					if( j == 1800 ){ z[0] = z[1] = u - 100;}
					if( j == 1900 ){ z[0] = z[1] = u + 100;}
				/*----------------------------------------------------------------------------------*/
					IxHpfilter1( &y[0], u, k, &z[0], wk );
					y[1] = ClibHpfilter1( u, k, &z[1] );
					if( y[0] != y[1] ){ HpfNgCnt++;}
					if( z[0] != z[1] ){ HpfNgCnt++;}
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
					if( 0 ){ printf( "\ny[0]=%8d, y[1]=%8d", y[0], y[1] );}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
				}
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check LpftNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( LpfNgCnt == 0 )
		{
			printf( "\nTstIxInstLpfilter1() : Complete" );
		}
		else
		{
			printf( "\nTstIxInstLpfilter1() : Error" );
			return( TSTNG );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Check HpftNgCnt																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( HpfNgCnt == 0 )
		{
			printf( "\nTstIxInstHpfilter1() : Complete" );
		}
		else
		{
			printf( "\nTstIxInstHpfilter1() : Error" );
			return( TSTNG );
		}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
/*--------------------------------------------------------------------------------------------------*/
		return( TSTOK );
}



/****************************************************************************************************/
/*																									*/
/*		Test Nxfilter2 Instruction																	*/
/*																									*/
/****************************************************************************************************/
/****************************************************************************************************/
/*		Pcal Function																				*/
/****************************************************************************************************/
void	PcalIxInstNxfilter2( LONG ts, LONG hz, LONG q, LONG d, LONG kl[], double kf[] )
{
LONG	i;
double	hx,wx;
double	qx,dx,bx;
/*--------------------------------------------------------------------------------------------------*/
/*		Cal. hx,wx,etc																				*/
/*--------------------------------------------------------------------------------------------------*/
		qx = (double)q / 1000.0;
		dx = (double)d / 1000.0;
		hx = 2.0 * 1000000000.0 / (double)ts;
		wx = 2.0 * 3.1415926536 * (double)hz;
		bx = hx*hx + wx*hx/qx + wx*wx;
/*--------------------------------------------------------------------------------------------------*/
/*		Cal. kf[i],kl[i]																			*/
/*--------------------------------------------------------------------------------------------------*/
		kf[0] = ((2.0*(wx*wx - hx*hx) / bx) * pow( 2.0, NXF_PRM_BITS ));
		kf[1] = (((hx*hx - dx*wx*hx/qx + wx*wx) / bx) * pow( 2.0, NXF_PRM_BITS ));
		kf[2] = ((2.0*(wx*wx - hx*hx) / bx) * pow( 2.0, NXF_PRM_BITS ));
		kf[3] = (((hx*hx - wx*hx/qx + wx*wx) / bx) * pow( 2.0, NXF_PRM_BITS ));
		kf[4] = (((hx*hx + dx*wx*hx/qx + wx*wx) / bx) * pow( 2.0, NXF_PRM_BITS ));
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; i<5; i++ )
		{
			kl[i] = (LONG)kf[i];
		}
/*--------------------------------------------------------------------------------------------------*/
		return;
}
/****************************************************************************************************/
/*		２次ノッチフィルタ (Double Version)															*/
/****************************************************************************************************/
void	IxNxfilter2D( double *x, double u, double k[5], double z[4], double wk[4], LONG NxfPrmBits )
{
/*--------------------------------------------------------------------------------------------------*/
/*		wk[0] = k[4] * u																			*/
/*--------------------------------------------------------------------------------------------------*/
		wk[0] = k[4] * u;
		wk[0] = wk[0] / pow( 2, NxfPrmBits );
/*--------------------------------------------------------------------------------------------------*/
/*		wk[0] = wk[0] + (k[0] * z[0]) + (k[1] * z[1])												*/
/*--------------------------------------------------------------------------------------------------*/
		wk[1] = k[0] * z[0];
		wk[1] = wk[1] / pow( 2, NxfPrmBits );
		wk[0] = wk[0] + wk[1];
/*--------------------------------------------------------------------------------------------------*/
		wk[1] = k[1] * z[1];
		wk[1] = wk[1] / pow( 2, NxfPrmBits );
		wk[0] = wk[0] + wk[1];
/*--------------------------------------------------------------------------------------------------*/
/*		wk[0] = wk[0] - (k[2] * z[2]) - (k[3] * z[3])												*/
/*--------------------------------------------------------------------------------------------------*/
		wk[1] = k[2] * z[2];
		wk[1] = wk[1] / pow( 2, NxfPrmBits );
		wk[0] = wk[0] - wk[1];
/*--------------------------------------------------------------------------------------------------*/
		wk[1] = k[3] * z[3];
		wk[1] = wk[1] / pow( 2, NxfPrmBits );
		*x    = wk[0] - wk[1];
/*--------------------------------------------------------------------------------------------------*/
/*		Update z[i]																					*/
/*--------------------------------------------------------------------------------------------------*/
		z[1] = z[0];
		z[0] = u;
		z[3] = z[2];
		z[2] = *x;
/*--------------------------------------------------------------------------------------------------*/
		return;
}
/****************************************************************************************************/
/*																									*/
/*		Linex(stdout)/Liney(fpx)の表示																*/
/*																									*/
/****************************************************************************************************/
void	FprintLineXY( FILE *fpy, LONG linex, LONG liney )
{
LONG	i;
/*--------------------------------------------------------------------------------------------------*/
/*		Output Line to stdout																		*/
/*--------------------------------------------------------------------------------------------------*/
		if( linex > 0 )
		{
			putchar( '\n' );
			for( i=0; i<linex; i++ ){ putchar( '-' );}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Output Liney to fpx																			*/
/*--------------------------------------------------------------------------------------------------*/
		if( (fpy != NULL) && (liney > 0) )
		{
			fputc( '\n', fpy );
			for( i=0; i<liney; i++ ){ fputc( '-', fpy );}
		}
/*--------------------------------------------------------------------------------------------------*/
		return;
}
/****************************************************************************************************/
/*																									*/
/*		Ｓｉｎ信号の作成																			*/
/*																									*/
/****************************************************************************************************/
LONG	MakeSinSignal(
		double	timex,					/* 現在時間		[ms]										*/
		double	amp,					/* Ｓｉｎ振幅	[--]										*/
		double	hz		)				/* Ｓｉｎ周波数	[0.1hz]										*/
{
LONG	ix;
double	tx,ax,sx;
double	pi = 3.1415926535;
/*--------------------------------------------------------------------------------------------------*/
/*		SinSignal Cal.																				*/
/*--------------------------------------------------------------------------------------------------*/
		if( hz == 0.0 )
		{
			sx = amp;
		}
		else
		{
			tx = 10000.0/hz;
			ix = (LONG)(timex/tx);
			ax = timex - (double)ix*tx;
			if( ax < 0.0 ) ax = ax + tx;
			sx = amp*sin( 2.0*pi*(ax/tx) );
		}
/*--------------------------------------------------------------------------------------------------*/
		return( (LONG)sx );
}
/****************************************************************************************************/
/*		Test Data for Step Response																	*/
/****************************************************************************************************/
const	LONG	TdatNxfilter2SR[][5] = {
/*--------------------------------------------------------------------------------------------------*/
/*		 ts[ns]		hz[Hz]		q[0.001]	d[0.001]	u											*/
/*--------------------------------------------------------------------------------------------------*/
		 62500,		 100,		500,		0,			0x01000000,				/*					*/
		 62500,		 500,		500,		0,			0x01000000,				/*					*/
		 62500,		1000,		500,		0,			0x01000000,				/*					*/
		 62500,		2000,		500,		0,			0x01000000,				/*					*/
/*--------------------------------------------------------------------------------------------------*/
		 62500,		 100,		1000,		0,			0x01000000,				/*					*/
		 62500,		 500,		1000,		0,			0x01000000,				/*					*/
		 62500,		1000,		1000,		0,			0x01000000,				/*					*/
		 62500,		2000,		1000,		0,			0x01000000,				/*					*/
/*--------------------------------------------------------------------------------------------------*/
		 62500,		 100,		1000,		500,		0x01000000,				/*					*/
		 62500,		 500,		1000,		500,		0x01000000,				/*					*/
		 62500,		1000,		1000,		500,		0x01000000,				/*					*/
		 62500,		2000,		1000,		500,		0x01000000,				/*					*/
/*--------------------------------------------------------------------------------------------------*/
		 62500,		 100,		1000,		1000,		0x01000000,				/*					*/
		 62500,		 500,		1000,		1000,		0x01000000,				/*					*/
		 62500,		1000,		1000,		1000,		0x01000000,				/*					*/
		 62500,		2000,		1000,		1000,		0x01000000,				/*					*/
/*--------------------------------------------------------------------------------------------------*/
		 63000,		 100,		 500,		0,			1000000,				/*					*/
/*--------------------------------------------------------------------------------------------------*/
};
/****************************************************************************************************/
/*		Test Data for Frequency Response															*/
/****************************************************************************************************/
const	LONG	TdatNxfilter2FR[][8] = {
/*--------------------------------------------------------------------------------------------------*/
/*		 ts[ns]		hz[Hz]		q[0.001]	d[0.001]	ufs		ufe		duf		uamp				*/
/*--------------------------------------------------------------------------------------------------*/
		 62500,		 100,		 500,		0,			10,		2000,	10,		1000000,
		 62500,		 100,		1000,		0,			10,		2000,	10,		1000000,
		 62500,		 500,		 500,		0,			10,		2000,	10,		1000000,
		 62500,		 500,		1000,		0,			10,		2000,	10,		1000000,
		 62500,		1000,		 500,		0,			10,		2000,	10,		1000000,
		 62500,		1000,		1000,		0,			10,		2000,	10,		1000000,
		 62500,		2000,		 500,		0,			10,		2200,	10,		1000000,
		 62500,		2000,		1000,		0,			10,		2200,	10,		1000000,
/*--------------------------------------------------------------------------------------------------*/
};
/****************************************************************************************************/
/*		Test Function																				*/
/****************************************************************************************************/
LONG	TstIxInstNxfilter2( void )
{
LONG	i,n;
LONG	j,jx;
double	timex;
LONG	ts,hz,q,d;
DWREG	wk[4][4];
LONG	u,x[4],z[4][4],k[4][5];
double	fx[4],fz[4][4],fk[4][5],fwk[4][4];
LONG	uhz,ufs,ufe,duf,uamp;
LONG	umax,umin;
LONG	xmax[4],xmin[4];
double	dwk1,dwk2,dwk3;
double	fxmax[4],fxmin[4];
double	GainX[4][2],GainF[5][2];
LONG	NfxPrmBits = NXF_PRM_BITS;
FILE*	LogFpx = NULL;
LONG	StepResFlag = 0;
UCHAR	LogFile[] = "IxNxfilter2.log";
LONG	TstDatNumSR = sizeof(TdatNxfilter2SR) / sizeof(TdatNxfilter2SR[0]);
LONG	TstDatNumFR = sizeof(TdatNxfilter2FR) / sizeof(TdatNxfilter2FR[0]);

/*--------------------------------------------------------------------------------------------------*/
/*		Open LogFile																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( (LogFpx = fopen( LogFile, "wt" )) == NULL )
		{
			printf("\n\n##### Error : LogFile (%s) Open Error #####\n", LogFile );
			return( TSTNG );
		}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
/*--------------------------------------------------------------------------------------------------*/
/*		Step Response Test Loop																		*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; 0 && (i < TstDatNumSR); i++ )
		{
			if( (i == 0) && (LogFpx != NULL) )
			{
				StepResFlag = 1;
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
				fprintf( LogFpx, "***** IxNxfilter2 Step Response *****" );
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
				FprintLineXY( LogFpx, 78, 125 );
			}
		/*------------------------------------------------------------------------------------------*/
			ts = TdatNxfilter2SR[i][0];
			hz = TdatNxfilter2SR[i][1];
			q  = TdatNxfilter2SR[i][2];
			d  = TdatNxfilter2SR[i][3];
			u  = TdatNxfilter2SR[i][4];
			PcalIxInstNxfilter2( ts, hz, q, d, k[0], fk[3] );
			for( j=0; j<5; j++ ){ fk[0][j] = (double)k[0][j];}
		/*------------------------------------------------------------------------------------------*/
			XprintF1( LogFpx, "\nts=%d[ns]",	ts		);
			XprintF1( LogFpx, ", hz=%d[Hz]",	hz		);
			XprintF1( LogFpx, ", q=%d[0.001]",	q		);
			XprintF1( LogFpx, ", d=%d[0.001]",	d		);
			XprintF1( LogFpx, "\nk[0]=%9d",		k[0][0]	);
			XprintF1( LogFpx, ", k[1]=%9d",		k[0][1]	);
			XprintF1( LogFpx, ", k[2]=%9d",		k[0][2]	);
			XprintF1( LogFpx, ", k[3]=%9d",		k[0][3]	);
			XprintF1( LogFpx, ", k[4]=%9d",		k[0][4]	);
			FprintLineXY( LogFpx, 78, 125 );
		/*------------------------------------------------------------------------------------------*/
		/*	NxFilter Cal. Loop																		*/
		/*------------------------------------------------------------------------------------------*/
			memset( z,  0x00, sizeof(z)  );
			memset( fz, 0x00, sizeof(fz) );
		/*------------------------------------------------------------------------------------------*/
			for( j=0; j < 1000; j++ )
			{
				timex = (double)j * (double)ts / 1000000.0;
			/*--------------------------------------------------------------------------------------*/
				IxNxfilter2(  &x[0],  u, k[0],  z[0],  wk[0]  );				/* Long   Prm24bits	*/
				IxNxfilter2D( &fx[0], u, fk[0], fz[0], fwk[0], NfxPrmBits );	/* Double Prm24bits	*/
				IxNxfilter2D( &fx[3], u, fk[3], fz[3], fwk[3], NfxPrmBits );	/* Double Normal	*/
			/*--------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
				if( 1 )
				{
					fprintf( stdout, "\nt=%6.3f",		timex	);
					fprintf( stdout, ", u=%9d",			u		);
					fprintf( stdout, ", x[0]=%9d",		x[0]	);
					fprintf( stdout, ", fx[0]=%13.3f",	fx[0]	);
					fprintf( stdout, ", fx[3]=%13.3f",	fx[3]	);
				}
			/*--------------------------------------------------------------------------------------*/
				if( LogFpx != NULL )
				{
					fprintf( LogFpx, "\nt=%6.3f",		timex	);
					fprintf( LogFpx, ", u=%9d",			u		);
					fprintf( LogFpx, ", x[0]=%9d",		x[0]	);
					fprintf( LogFpx, ", fx[0]=%13.3f",	fx[0]	);
					fprintf( LogFpx, ", fx[3]=%13.3f",	fx[3]	);
				}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
			}
		}
/*--------------------------------------------------------------------------------------------------*/
/*		Frequency Response Test Loop																*/
/*--------------------------------------------------------------------------------------------------*/
		for( i=0; 1 && (i < TstDatNumFR); i++ )
		{
			if( (i == 0) && (LogFpx != NULL) )
			{
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
				if( StepResFlag ){ fprintf( LogFpx, "\n\n\n" );}
				fprintf( LogFpx, "***** IxNxfilter2 Frequency Response *****" );
				FprintLineXY( LogFpx, 78, 125 );
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
			}
		/*------------------------------------------------------------------------------------------*/
			ts = TdatNxfilter2FR[i][0];
			hz = TdatNxfilter2FR[i][1];
			q  = TdatNxfilter2FR[i][2];
			d  = TdatNxfilter2FR[i][3];
		/*------------------------------------------------------------------------------------------*/
			ufs = TdatNxfilter2FR[i][4];
			ufe = TdatNxfilter2FR[i][5];
			duf = TdatNxfilter2FR[i][6];
			uamp= TdatNxfilter2FR[i][7];
		/*------------------------------------------------------------------------------------------*/
			PcalIxInstNxfilter2( ts, hz, q, d, k[0], fk[3] );
			for( j=0; j<5; j++ ){ fk[0][j] = (double)k[0][j];}
		/*------------------------------------------------------------------------------------------*/
			XprintF1( LogFpx, "\nts=%d[ns]",	ts		);
			XprintF1( LogFpx, ", hz=%d[Hz]",	hz		);
			XprintF1( LogFpx, ", q=%d[0.001]",	q		);
			XprintF1( LogFpx, ", d=%d[0.001]",	d		);
			XprintF1( LogFpx, ", Uamp=%d",		uamp	);
			XprintF1( LogFpx, "\nk[0]=%9d",		k[0][0]	);
			XprintF1( LogFpx, ", k[1]=%9d",		k[0][1]	);
			XprintF1( LogFpx, ", k[2]=%9d",		k[0][2]	);
			XprintF1( LogFpx, ", k[3]=%9d",		k[0][3]	);
			XprintF1( LogFpx, ", k[4]=%9d",		k[0][4]	);
			FprintLineXY( LogFpx, 78, 125 );
		/*------------------------------------------------------------------------------------------*/
		/*	NxFilter Cal. Loop																		*/
		/*------------------------------------------------------------------------------------------*/
		    for( uhz=ufs; uhz<=ufe; uhz+=duf )
			{
				memset( z,  0x00, sizeof(z)  );
				memset( fz, 0x00, sizeof(fz) );
				umax = 0; umin = uamp;
				for( j=0; j<4; j++ ){ xmax[j]=0;  xmin[j]=uamp;}
				for( j=0; j<4; j++ ){ fxmax[j]=0; fxmin[j]=uamp;}
				jx = (LONG)((128.0*1000000000.0)/((double)uhz*(double)ts));
			/*--------------------------------------------------------------------------------------*/
				for( j=0; j<(8000+jx); j++ )
				{
				    timex = (double)j*(double)ts/1000000.0;
				    u = MakeSinSignal( timex, uamp, 10*uhz );
					IxNxfilter2(  &x[0],  u, k[0],  z[0],  wk[0]  );
					IxNxfilter2D( &fx[0], u, fk[0], fz[0], fwk[0], NfxPrmBits );
					IxNxfilter2D( &fx[3], u, fk[3], fz[3], fwk[3], NfxPrmBits );
				/*----------------------------------------------------------------------------------*/
				    if( j >= 8000 )
				    {
						if( u  > umax ){ umax = u; }
						if( u  < umin ){ umin = u; }
						for( n=0; n<4; n++ )
						{
							if( x[n]  > xmax[n]  ){ xmax[n]  = x[n]; }
							if( x[n]  < xmin[n]  ){ xmin[n]  = x[n]; }
							if( fx[n] > fxmax[n] ){ fxmax[n] = fx[n];}
							if( fx[n] < fxmin[n] ){ fxmin[n] = fx[n];}
						}
				    }
				}
			/*--------------------------------------------------------------------------------------*/
				for( n=0; n<4; n++ )
				{
					GainX[n][0] = (double)xmax[n]/(double)uamp;
					GainX[n][1] = 20.0*log10( GainX[n][0] );
				/*----------------------------------------------------------------------------------*/
					GainF[n][0] = fxmax[n]/(double)uamp;
					GainF[n][1] = 20.0*log10( GainF[n][0] );
				}
			/*--------------------------------------------------------------------------------------*/
				dwk1 = ((double)uhz/(double)hz)*((double)uhz/(double)hz);
				dwk2 = 1.0 - 2.0*dwk1 + dwk1*dwk1;
				dwk3 = 1.0 + ((1000000.0/((double)q*(double)q))-2.0)*dwk1 + dwk1*dwk1;
				GainF[4][0] = sqrt( dwk2/dwk3 );
				GainF[4][1] = (GainF[4][0] != 0)? 20.0*log10( GainF[4][0] ) : -999.999;
			/*--------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
				if( 1 )
				{
					fprintf( stdout, "\nUhz=%4d",				uhz							);
					fprintf( stdout, ", Xmax=%9d",				xmax[0]						);
					fprintf( stdout, ", Xmin=%9d",				xmin[0]						);
					fprintf( stdout, ", GainX=%7.4f(%8.3fdB)",	GainX[0][0], GainX[0][1]	);
//					fprintf( stdout, ", GainF=%7.4f(%8.3fdB)",	GainF[3][0], GainF[3][1]	);
//				fprintf( stdout, ", 理論値=%7.4f(%8.3fdB)",	GainF[4][0], GainF[4][1]	);
				}
			/*--------------------------------------------------------------------------------------*/
				if( LogFpx != NULL )
				{
					fprintf( LogFpx, "\nUhz=%4d",				uhz							);
					fprintf( LogFpx, ", Xmax=%9d",				xmax[0]						);
					fprintf( LogFpx, ", Xmin=%9d",				xmin[0]						);
					fprintf( LogFpx, ", GainX=%7.4f(%8.3fdB)",	GainX[0][0], GainX[0][1]	);
					fprintf( LogFpx, ", GainF=%7.4f(%8.3fdB)",	GainF[3][0], GainF[3][1]	);
					fprintf( LogFpx, ", 理論値=%7.4f(%8.3fdB)",	GainF[4][0], GainF[4][1]	);
				}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
			}
		/*------------------------------------------------------------------------------------------*/
			FprintLineXY( LogFpx, 78, 125 );
		}
/*--------------------------------------------------------------------------------------------------*/
/*		End Procedure																				*/
/*--------------------------------------------------------------------------------------------------*/
#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		if( LogFpx != NULL ){ fprintf( LogFpx, "\n\n" ); fclose( LogFpx );}
#endif	//#ifdef WIN32			/* VCのみ有効(ASIPコンパイラ対応)			*/
		return( TSTOK );
}








/**************************************** end of file ***********************************************/
